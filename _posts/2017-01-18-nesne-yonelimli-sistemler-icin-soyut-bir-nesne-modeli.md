---
ID: 39
post_title: >
  Nesne Yönelimli Sistemler Için Soyut
  Bir Nesne Modeli
author: Midori Kocak
post_excerpt: ""
layout: post
permalink: >
  https://www.meraklibilisimci.com/nesne-yonelimli-sistemler-icin-soyut-bir-nesne-modeli/
published: true
post_date: 2017-01-18 16:09:18
---


<h4>Alan Snyder Yazılım Teknolojisi Laboratuvarı HPL-90–22 Nisan 1990 Çeviri: Midori Koçak — mtkocak (at) gmail (dot) com 30.12.2016</h4>
<figure>

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/01/74008-1ynt6ev0ifl5scd5ipnrfwa.png">
</figure><p>Anahtar kelimeler: nesne-yönelimli programlama, nesne yönelimli sistemler, nesne modelleri, veri modelleri, dağıtık sistemler, nesne yönetimi</p>
<p>Bu rapor, nesne yönelimli sistemler için soyut bir nesne modeli tanımlamaktadır. Soyut nesne modeli temel kavramlar ve terminolojinin organize bir şekilde sunulmasını sağlamaktadır. (Soyut nesne modeli) dağıtık bir nesne yönetimi altyapısı üzerine kurulmuş uygulamalar tarafından görüldüğü şekilde kısmi bir hesaplama modeli tanımlamaktadır. Amacı, nesne sistemlerinin temel özelliklerini bünyesinde toplayan genel bir taslak sunmaktır. Bu çerçevede, genel modelin detaylandırılması (rafine edilmesi) ve doldurulması (genel modele ait belirli varlıkların tanımlanması) yoluyla, birçok belirli nesne modelini tanımlamak mümkün olmalıdır. Soyut model, Nesne Yönetim Grubu’nun kullanımı için, önerilen nesne teknolojilerini talep etmek, açıklamak ve değerlendirmek için ortak bir kavramsal çerçeve olarak geliştirilmiştir.</p>
<p>© Telif Hakkı Hewlett-Packard Company 1990</p>
<h4>Önsöz</h4>
<p>Bu rapor, Nesne Yönetim Grubunun teknik komitesi tarafından kullanılmak üzere hazırlanmıştır. (Rapor) OMG (çn. NYG olarak adlandırılacaktır) teknik komitesine, gelişen NYG standardının durumunu tanımlayan daha büyük bir belgenin parçası olması önerilmiştir. Bu rapor, OMG’nin resmi bir belgesi değildir. NYG standardının durumu hakkında daha fazla bilgi için, lütfen Nesne Yönetimi Grubuna başvurunuz. Nesne Yönetimi Grubu, Framingham Kurumsal Merkezi, 492 Old Connecticut Path, Framingham, Massachusetts 01701.</p>
<h4>Teşekkürler</h4>
<p>Bu rapor, Nesne Yönetim Grubunun teknik komitesinin bir faaliyeti olarak gerçekleştirilen çalışmaları belgelemektedir. Jeff Eastman, Jon Gustafson, Brian McBride, Ian Thomas, Jan te Kiefte, Lee Scheffler, Rod Bark, Pete Showman, Dennis Tenney ve Tom Allen gibi birçok insandan gelen görüşmelerden ve geribildirimden yararlanılmıştır. Özellikle, Bill Kent ile nesne arayüzleri, nesne kimliği ve nesne durumu konularında yapılan kapsamlı tartışmalardan yararlanılmıştır. Bill, genelleştirilmiş nesne modelini (çn. rapora) dahil etmek için ilk mücadeleye başlamamı sağladı ve olayları daha dikkatli ve açık bir şekilde açıklamam için birçok kez beni zorladı. Bill’in bu belgeye katkısıim, tüm konularda fikir birliğine vardığımz gibi algılanmamalıdır. Son olarak, bu çalışma Alain Couder tarafından başlatılan HP “nesne görev gücü’nün” daha önceki çalışmasının bir sonucudur.</p>
<h4>Giriş</h4>
<p>NYG nesne modeli, NYG nesne kavramlarının ve terminolojisinin organize bir sunumunu sağlamaktadır. Nesne modeli, NYG uyumlu uygulamaların ve son kullanıcı uygulamalarının karşılaştığı hesaplama modelini kısmen tanımlamaktadır. NYG nesne modelinin amacı, NYG tarafından önerilen teknolojiler için kavramsal bir çerçeve tanımlamak ve özellikle belirli teknolojileri önermek ve benimsemek için yapılacak temel tasarım seçimlerini motive etmektir.</p>
<p>NYG nesne modeli, bir NYG sisteminin bileşenlerini veya arabirimlerini tanımlamamaktadır. Nesne modeli, NYG uygulamalarının yapısını da tanımlamaz. Nesne modeli, belirli nesneleri, belirli türde nesneleri veya nesnelere özel arayüzleri tanımlamaz. Bu konular NYG referans modeli tarafından ele alınmaktadır.</p>
<p>Önerilen herhangi bir NYG teknolojisinin burada, modeli detaylı olarak anlatması ve oluşturması beklenmektedir. Modelin ayrıntılandırmak, örneğin talep öz niteliklerinin biçimini veya türleri belirlemek için kullanılan dili tanımlayarak daha belirli hale getirilmesi anlamına gelmektedir. Modeli doldurmak, model tarafından tanımlanan belirli varlık örneklerini, örneğin belirli nesneleri, belirli işlemleri veya belirli türleri ortaya koymak demektir.</p>
<p>Bu nesne modelinin bir amacı da, önerilen teknolojilerin olası modellerine gereksiz kısıtlamalar getirmekten kaçınmaktır. NYG nesne modelinde somutlaştırılan gereklilikler, nesne teknolojisi kavramı için “gerekli” kabul edilenlerdir.</p>
<p>Nesne sistemlerinin temel karakteristiği, nesne istemcileri tarafından görülen nesnelerin semantiği ile bu semantiklerin varolan veri gösterimleri ve çalıştırılabilir kod açısından uygulanımları arasındaki ayrımdır. Nesne semantiği, nesne oluşturma ve nesne kimliği, talep ve işlemler, türler ve imzalar gibi kavramları içerir. Nesne uygulanımı, yöntemler, veri yapıları, sınıflar (uygulanım tanımları gibi) ve uygulama kalıtımı gibi kavramları içermektedir.</p>
<p>Nesne modeli ilk önce nesne semantiği ile ilgili kavramları tanımlar ve ondan sonra nesne uygulanımı ile ilgili kavramları açıklar. Nesne semantiği istemcilere görünür olduğundan, nesne modeli, nesne semantiği kavramlarını tanımlamada en belirgin ve kural belirleyici kavramdır. Nesnenin uygulanımı ile ilgili tartışmalar daha fikir vericidir; çünkü nesnelerin farklı uygulanımları için farklı nesne teknolojileri kullanılmasını sağlayan maksimum özgürlük amaçlamaktadır.</p>
<p>Nesne sistemlerinin NYG nesne modelinin kapsamı dışında başka özellikleri de mevcuttur. Bu kavramların bazıları uygulama mimarisi bakış açıları olup, bazıları nesne teknolojisinin uygulandığı belirli alanlarla ilişkilendirilmiştir. Bu tür kavramlar mimari referans modelinde daha düzgün bir şekilde ele alınmaktadır. Hariç tutulan kavramlardan bazıları, bileşik nesneler, öz nitelikler ve bağlantılar, nesnelerin kopyalanması, değişim yönetimi ve işlemlerdir (transactions). Ayrıca NYG nesne modeli kapsamı dışında denetim ve yürütme modeli de vardır.</p>
<p>Nesne modeli tanımında, yeni terimleri tanıtmak veya tanımlamak için italik kullanılır. Parantezli cümleler ve girintili paragraflar yorumdur ve nesne modelinin bir parçası değildir.</p>
<h4>1.1 Klasik vs. Genelleştirilmiş Nesne Modelleri</h4>
<p>Aşağıda tanımlandığı gibi, NYG nesne modeli genelleştirilmiş bir nesne modelidir. Bu nedenle, mevcut sistemlerden aşina olunan nesne modellerinden derin bir biçimde farklıdır. NYG nesne modeli kasıtlı bir şekilde, aşina olunan nesne modellerinin genelleştirilmesidir. NYG nesne modelini açıklamaya geçmeden önce, bu iki farklı nesne modelini karşılaştırmak ve farklarını vurgulamak faydalı olacaktır. Bu açıklamalarda kullanılacak terimler daha sonra açıklanacak olmasına rağmen, anlamlarının sezilmesi kolay terimlerdir.</p>
<p>Çoğu nesne teknolojisinde kullanılan klasik nesne modelinde, bir istemci nesneye mesaj göndermektedir. Kavramsal olarak, nesne, hangi hizmetin gerçekleştirileceğine karar vermek için mesajı yorumlar. Klasik modelde, talep, nesneyi ve sıfır veya daha fazla öz niteliği tanımlamaktadır. Çoğu klasik nesne modelinde, gerçekleştirilecek işlemi tanımlayan özellikle bir ilk parametre tanımlanması gerekir; Mesaj, talep edilen işlemi temel alan metodun seçilerek yorumlanır. Tabii olarak, metod seçimi nesne veya sistem tarafından gerçekleştiriliyor olabilir.</p>
<p>Genelleştirilmiş nesne modeli istemcinin bir işlem belirttiği bir talep ve herhangi birinin nesne belirtebileceği sıfır veya daha fazla öz nitelik bildiriminde bulunduğu modeldir. (Örnek olarak Genelleştirilmiş nesne modeli Common Lisp Nesne Sistemi ve Iris Veritabanı tarafından kullanılmaktadır.) Genelleştirilmiş nesne modelinde, metod seçimi, talebin yanı sıra işlemde tanımlanan nesnelerden herhangi birine dayanabilir. Yöntem seçimi birden fazla nesneye dayandığından, seçimin nesne değil sistem tarafından yapıldığı iyice görülmektedir. Metod seçimi, uygulamada çok aşamalı olarak gerçekleştirir, son aşama nesne tarafından tamamlanır.</p>
<p>Klasik nesne modeli, genelleştirilmiş nesne modelinin özel bir halidir. Nesneye klasik olarak bir mesaj göndermek, metod seçiminin işleme bağlı olduğu ve nesnenin ilk öz nitelik aracılığıyla tanımlandığı genelleştirilmiş talebe eşdeğerdir. Örneğin klasik modelde “yazdır yazıcı-a” mesajını “hesap_tablosu-a” nesnesine gönderme işlemi, metod seçiminin yazıcı-a nesnesine değil, hesap_tablosu-a nesnesine bağlı olduğu varsayıldığında, genelleştirilmiş modelde “yazdır hesap_tablosu-a yazıcı_a” talebini bildirmeye eşdeğerdir.</p>
<p>Genelleştirilmiş nesne modeli, bir nesne teknolojisinin ek işlevsellik sağlamasına olanak tanır. Örneğin, nesne teknolojisi, sadece bir elektronik tabloda ve belirli bir tür yazıcıda yazdırma işlemi talep edildiğinde çağrılan bir metodun tanımlanmasını destekleyebilir. Bu özelleşmiş metod, belirli yazıcı türlerinin benzersiz özelliklerinden yararlanabilir.</p>
<p>Klasik nesne modellerinin dağıtık uygulamaları genellikle nesnelerin konumlarını belirler. Genelleştirilmiş modellerde ise, işlemlere konumlar atamak da mümkündür. Böylece, uzaktan yordam çağrıları da genelleştirilmiş nesne modelinin özel bir örneğidir.</p>
<h4>Genel bakış</h4>
<p>NYG sistemi, kod ve veri içeren bir hesaplama sistemidir.</p>
<blockquote>Bu belgede ele alınan bakış açısı, sadece tek bir NYG hesaplama sisteminin varolduğunu kabul etmektedir. (Sistem birden çok birbirinden ayrı hesaplama parçalarını içeriyor olabilir.) Bu bakış açısının sebebi, farklı hesaplama parçalarının, daha sonra tek bir parça olarak bağlandığı durumları zarifçe ele almaktır. Bu açıklama, belirli bir nesne teknolojisinde, bağımsız nesne sistemlerinin (ağlar), istendiğinde birbirine bağlanabilmesini desteklemesi gerektiğini belirtmemektedir. Diğer bir değişle, nesne modeli evrensel isimlendirme mimarisini desteklemek zorunda değildir.</blockquote>
<p>NYG sistemindeki varlıklar, NYG nesnelerini, değerler (nesne adları ve tutamaçları dahil), işlemler, imzalar ve türleri (arayüz türleri dahil) içerir.</p>
<h4>Nesne Semantiği</h4>
<p>Bu bölüm, nesne semantiği ile ilişkili kavramları, yani nesneleri kullanma ile ilgili kavramları tanımlamaktadır. (Bkz. Şekil 1.)</p>
<h4>3.1 Nesneler</h4>
<p>NYG hesaplama modeli, NYG nesneleri olarak bilinen varlıkları içerir. (NYG nesneleri, C++ nesneleri gibi nesneler olarak da adlandırılan diğer muhtemel nesnelerle karıştırılmamalıdır. Kısaltma amacıyla, NYG nesnelerine bundan böyle nesneler denilecektir. Nesnelerin aşağıda açıklanan bazı özellikleri mevcuttur.<br>Bir nesne, istemcilere hizmet sağlama işleminde rol alır. Bir hizmetin istemcisi, hizmeti talep etme yeteneğine sahip herhangi bir varlıktır. (İstemciler, uygulama programları, nesneler, aracılar ve bir kullanıcı arayüzü aracılığıyla hareket eden son kullanıcıları içerebilir.)</p>
<h4>3.2 Talepler</h4>
<p>İstemciler talep bildirerek, hizmet talep ederler. Bir talep, diğer bir deyişle, hesaplama sisteminin çalışması esnasında, belirli bir zamanda meydana gelen bir şeydir. Bir taleple ilgili olan bilgi, istenen işlemden ve sıfır veya daha fazla (gerçek) öz nitelikten oluşmaktadır.</p>
<blockquote>Bir talebin, çalıştırıldığında bir talep bildirilmesine yol açan, statik bir program metninden farklı birşey olduğu anlaşılmalıdır. Nesne modeli, hangi programların talep bildireceğini belirleyen bi söz dizimi dikte etmez. Örneğin talep bildiren bir yapıda, işlemin önce gelmesini gerektirmez. Nesne modeli, bir programın hangi işlemleri veya hangi öz niteliklerin çalıştırılma esnasında neye tekabül ettiği ile ilgilenmez.</blockquote>
<blockquote>Talep içerisinde belirlenmiş olan bir işleme, işlem adı denmektedir. Nesne modeli, istemcilerin işlemlere nasıl isim verdiğini de tanımlamaz. Farklı istemcilerin aynı işlemi tanımlamak için farklı isimler veya aynı ismi farklı işlemleri tanımlamak için kullanmaları mümkündür.</blockquote>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/01/8fcd9-1rm6qthjldzcqjd6v7gmn6q.png">

<figcaption class="wp-caption-text">Birincil nesne semantiği kavramları</figcaption></figure><blockquote>Talep dendiğinde anlaşılması istenen şey, işemin gerçekleştirilen hizmeti tanımladığı ve öz niteliklerin hizmet sunumuna katılan nesneleri ve istemci tarafından istenen sonuçları belirten diğer bilgileri tanımladığıdır. Bu nesne modeli, alışılagelmiş tek nesneli taleplere ek olarak, bir talebin sıfır veya daha fazla nesneyi adlandırmasına olanak vermektedir.</blockquote>
<p>İşlemler (olasılıkla) jeneriklerdir, yani, nesnelerden talep edilen tek bir işlem, gözlemlenebilen farklı davranışlara yol açan, farklı uygulanımlara sahip olabilir.</p>
<blockquote>Bu, hesaplama modelini karakterize etmesi amaçlanan felsefi bir ilkedir. Burada amaçlanan, farklı nesnelerden, belirli bir işlem talep edildiğinde, hizmeti gerçekleştirmeyi amaçlandığında yürütülecek kodun farklı farklı olabileceği ve farklı bir şekilde gözlemlenebilir davranışlara yol açabileceğidir. Özellikle, varolan işlemler için özelleşmiş davranışlar sağlayan yeni bir çeşit nesne sisteme eklenebilir. Belirli bir işlem için, farklı davranışlar, birşeyin yazdırılması gibi ortak bir amaca sahip olmaları beklenir, fakat, bu beklenti sistem tarafından zorlanan bir durum değildir.</blockquote>
<p>İşlemler açık eylemler tarafından yaratılırlar, bu tarz eylemlerin her biri gelecekte yaratılacak veya daha önce yaratılmış olan işlemlerden farklıdır.</p>
<blockquote>Bu tanımlama, aşağıda açıklanan nesne kimliğine eşdeğer bir kavram olan işlem kimliği fikrini açıklamaktadır. Temel bir seviyede, işlemlerde “kaza sonucu” aşırı yüklenme olamaz: İki istemcinin aynı işlemi belirtmesi için işlem kimliğinin ortak bir kaynaktan her bir istemciye iletilmiş olması gerekir. Dolayısıyla, geliştirici, (yeni bir işlem oluşturarak) hizmetin diğer hizmetlerden açıkça farklı olduğundan emin olacağı yeni bir hizmet tanımlayabilir.</blockquote>
<blockquote>Nesne mode bir işlemin bir nesne veya bir işlem adının (örneğin öz nitelik olarak kullanılabilecek) bir değer olduğunu tanımlamaz.</blockquote>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/01/7686d-1c8fd3haxano09cumylka2a.png">

<figcaption class="wp-caption-text">Talep kavramları</figcaption></figure><p>Değer, bir talep içerisinde bulunan, olası (gerçek) bir öz niteliktir. Değer, talebi gerçekleştirmek amacıyla, nesneyi tanımlayabilir. Nesneyi tanımlayan değere, nesne adı denir. (Bkz. Şekil 2.)</p>
<blockquote>Nesneler dışındaki soyut varlıkları tanımlayan değerler olabilir. Bu tür değerlere değişmez (literal) denir. Örneğin, değişmez dendiğinde, bu değerlerin mutlaka derleme zamanı sabitleri olduğu kastedilmemektedir. Örneğin belirli bir sistemde, tamsayılar talepler içerisinde tanımlanmış olabilirler, fakat, sistem tarafından tanımlanan nesnelerin tüm özelliklerine sahip olmayabilirler. Başka bir deyişle, nesne modeli izin verse dahi tüm referanslanabilir varlıkların nesne olmasını gerekmez. Ayrıca, var olan herhangi bir varlığı referans göstermeyen anlamsız değerler de olabilir. Örneğin, henüz oluşturulmamış nesneleri tanımlamak için bazı değerler saklı tutulabilir. Bu durum, bir sonraki bahiste görmezden gelinmektedir.</blockquote>
<p>Tanıtıcı (tutamaç, handle), belirli bir nesneyi açıkça tanımlayan bir nesne adıdır. Uzay, zamanın belirli pragmatik sınırları içerisinde, bir tanıtıcı, bir talep içerisinde kullanıldığı zaman, her seferinde aynı nesneyi güvenilir bir şekilde tanımlar.</p>
<blockquote>Bir nesne teknolojisi, farklı nesneleri farklı zamanlarda veya farklı “lokasyonlarda” tanımlayan nesne adları sağlayabilir, örneğin belirli bir türdeki en yakın yazıcıyı gösteren bir değer gibi. Bu değerler nesne adlarıdır, ancak tanıtıcılar (handle) değillerdir. İkisi de yararlı olmasına rağmen, güvenilir, belirsiz olmayan nesne adlarının (tanıtıcılar) varlığı bir nesne sisteminin vazgeçilmez bir özelliğidir.</blockquote>
<blockquote>Nesne isimleri ve tanıtıcılar arasındaki ayrım, Unix dosya sistemine benzetme yapılarak anlatılabilir. Unix dosyalarının nesneler olduğunu ve bir Unix dosyasını tanımlamanın üç olası yolu olduğunu göz önünde bulundurun: yol adları, dosya tanımlayıcıları ve inode’lar. Bir yol adı, bir nesne adıdır, ancak bir tanıtıcı değildir, çünkü bir yol adına göre adlandırılmış dosya, dosyaları veya dizinleri yeniden adlandırma sonucunda anında değişebilir. (Göreceli bir yol adı, verilen bir işlem tarafından belirli bir zamanda “geçerli” olarak tanımlanan dosya dizinindeki yoruma bağımlı olmasıyla ek bir belirsizliğe sahiptir.) Bir dosya tanımlayıcı, bir tanıtıcıdır çünkü tek bir işlemde (veya dosya tanımlayıcıları paylaşılıyorsa işlem ağacında), aynı dosya nesnesini her zaman tanımlamaktadır. Bir inode belirli bir dosyayı tek bir dosya sistemi bağlamında belirgin olarak tanımlamış olsa da bir inode bir nesne adı değildir çünkü bir değer değildir (olağan Unix sistem çağrılarında kullanılamaz), Hem yol adları, hem de dosya tanımlayıcıları olması faydalıdır. Unix’in en büyük kısıtlılığı, dosya tanımlayıcısının kalıcı bir biçiminin olmamasıdır.</blockquote>
<blockquote>Nesne modeli, bir nesnenin tek bir bağlamda veya farklı bağlamlarda birden çok işleme sahip olmasını sağlar. Örneğin, bir Unix işlemi bağlamında bir tanıtıcı, o işlemin adres alanına işaretçi olabilir. Farklı işlemlerde, aynı nesne farklı işaretçilerle tanımlanır. Bu tür tanıtıcılar (handle), yalnızca işlemin adres alanı içinde ve yalnızca işlemin ömrü boyunca geçerlidir. (Yukarıdaki Unix dosya sistemi örneği, bir nesnenin tek bir bağlamda birden fazla tanıtıcısına işaret etmektedir: Bir Unix işlemi, aynı dosyayı tanımlayan birden çok dosya tanımlayıcısına sahip olabilir. Dosya tanımlayıcıları, dosyayla farklı ilişkili konumlara sahip olmalarıyla ayrışırlar.)</blockquote>
<p>Bir nesne, bir veya daha fazla gerçek parametre o nesneyi tanımlıyorsa, bir talebe katılmak üzere tanımlanmıştır. (“Katılmak” sözcüğünü ile nesnenin gerçekten istenen hizmeti sunmasındaki herhangi görev derecesi kastedilmemektedir.)</p>
<p>Bir talep, bir hizmetin istemci adına gerçekleştirilmesine yol açar. Hizmeti gerçekleştirmenin bir sonucu, bazı sonuçların istemciye geri gönderilmesi olabilir. Bir taleple ilişkili sonuçlar, istenen hizmeti gerçekleştirmeye çalışırken istisnai koşulların ortaya çıktığını gösteren değerlerin birlikte farklı değerler de içerebilir.</p>
<p>Nesne modeli, bir istemci tarafından parametrelerin, sonuçların ve istisnai koşulların nasıl tanımlandığını belirtmez. Parametrelerin ve sonuçların tanımlanması ardışık / konumsal veya isimlerle olabilir. Bu ayrıntılar, bu modeli ayrıntılı olarak anlatan belirli bir nesne teknolojisi tarafından belirlenir.</p>
<p>Nesne modelinin, bir işlemin, istemci programlarında statik olarak tanımlanması gerektiğini belirtmediğini unutmayın. Örneğin, bir programlama dili arayüzü, işlem adının değişken olarak varolduğu bir talepte bulunmak için bir yapı sunuyor olabilir. Böyle bir yapı Lisp’deki “funcall” yapısına benzer olacaktır.</p>
<h4>3.3 Davranış ve Soyutlama</h4>
<p>Bir talebin davranışı, istenen hizmetin gerçekleştirilmesinden kaynaklanan gözlenebilir etkilerdir. (Etki, istekte bulunan istemci dışındaki taraflar tarafından görülebilir.) Bir talebin davranışı, istemciye (geri gönderilen değerler ve rapor edilen istisnai koşullar dahil olarak) geri döndürülen sonuçların yanısıra (aynı veya farklı bir istemci tarafından) gelecekteki sonuçlarla ilgili dolaylı etkileri içerir.</p>
<p>Genel olarak, bir isteğin muhtemel davranışları, diğer istekleri bildiren hesaplamaları da kapsayan herhangi bir rastgele hesaplamadır. (Bu ifade, hesaplama modelinin kastedilen gücünü karakterize etmektedir.)</p>
<p>Bir isteğin davranışı genellikle hem talebin gerçek öz niteliklerine, hem de hesaplama sisteminin durumuna bağlıdır. Hesaplama sisteminin durumu geçmiş isteklerin tarihçesinin bir gösterimidir; özellikle, geçmiş isteklerin gelecekteki davranış üzerindeki etkilerini temsil etmektedir. Bir davranış, öz nitelikleri, talebin gerçek argümanlarını ve sistemin durumunu içeren bir fonksiyon olarak modellenebilir. (Teknik olarak, bu teknik düzanlamsal semantik olarak adlandırılır.)</p>
<blockquote>Sistemin durumu, fiziksel olarak, isteklerin yürütülmesi arasında kalıcı olan verilerle temsil edilir. Bu “kalıcı veriler”, nesne etkili bir şekilde temsil eden referansları içerebilir. Nesne modeli, bu gibi referansların depolanmış biçimi hakkında hiçbir şey söylemez. Kalıcı nesne referansları, yalnızca talep argümanları veya sonuçları olarak iletilmiş değerler (nesne adları) aracılığıyla istemciler tarafından görülebilir. Örneğin, kalıcı bir nesne referansı, bir nesnenin belirli bir öz niteliğini döndüren, hizmetin sonucu olan değer olarak, istemciye açıklanabilir.<br>Bir isteğin davranışı, bağlamsal bilgiye (örneğin, istemcinin kimliğine) ve sistemle bağlantılı olan (bağlı bir donanım aygıtının durumu gibi) diğer varlıkların durumuna veya kullanıcıların doğrudan etkileşimlerin etkilerine bağlı olabilir. Bu ilave etkiler, davranış fonksiyonuna ek argümanlar olarak modellenmektedir.</blockquote>
<p>Bir nesne açıkça, ilgili taleplerin davranışı ile karakterize edilen soyutlamanın vücut bulmuş halidir. Bir nesne tarafından vücut bulmuş olan soyutlama, istemcileri için anlamlıdır. Son kullanıcı tarafından görülebilen bir nesne, tipik olarak, son kullanıcı tarafından aşina olunan bazı gerçek dünya nesnelerini modellemektedir.</p>
<blockquote>Bu felsefi ilkeler, anlamlı soyutlamalar oluşturmak için nesneleri kullanmadaki amacı açıklamaktadır. Elektronik tabloları değiştirebilmeyi hedefleyen bir istemciye, elektronik tablolardan beklenen hizmetleri gerçekleştiren nesneler sunulmalıdır. Bir e-tablo nesnesinin e-tablo gibi davranması, nesnenin özünde bulunur ve istemcinin bilgisine bağımlı değildir. Unix’ten karşıt bir örnek konuyu açıklığa kavuşturmaya yardımcı olabilir. Unix dosyası, değiştirilebilir bir bayt dizisinin düşük seviyeli soyutlamasıdır. Bir Unix dosyasına ek semantik eklenmemiştir; bunun yerine, bir Unix dosyasının yorumu dosyayı işleyen uygulamalara bırakılmıştır. Bir Unix dosyası bir e-tabloyu temsil edebilir, ancak Unix dosya sistemi bu amacı belirlemez. Bunun yerine, bu özel Unix dosyası üzerinde çalışırken elektronik tablo uygulamasını çağırmak istemcinin sorumluluğundadır. Bu ifadelerle, birden fazla soyutlama seviyesini destekleyen sistemleri dışarıda bırakmak kastedilemiştir.</blockquote>
<h4>3.4 Nesnelerin Yaratılması ve Kimliği</h4>
<p>Bir nesne, açık bir eylemle oluşturulur. Nesnenin kimliği vardır: daha önce yaratılmış olan veya hesaplama sisteminde yaratılacak olan her nesneden ayrıdır.</p>
<blockquote>Nesne kimliğinin bu kavramı, her nesne yaratma olayında bir nesne tanımlayıcısının önceden ayrılmadığı sonsuz bir nesne tanımlayıcıları kümesi varsayılarak resmi olarak modellenebilir. Nesne kimliği, nesne tanımlayıcılarının denkliği olarak modellenir. (Soyut nesne kimliği konusundan aşağıda bahsedilmektedir.) Nesne modelinin, hesaplama sisteminde benzersiz nesne tanımlayıcılarını açıkça kullanmasını gerektirmediğine dikkat edin. Benzersiz tanımlayıcılar bir uygulama tekniğidir. Benzersiz tanımlayıcılar kullanılsa bile, istemcilere gösterilmelerine gerek yoktur.</blockquote>
<p>Nesne oluşturma, işlemler yoluyla istemcilere sunulmaktadır. Nesne oluşturma işleminin sonucu, yeni oluşturulan nesneyi tanımlayan bir tanıtıcı şeklinde istemciye ifşa edilir.</p>
<p>Bir talebin davranışı, katılımcı nesnelerin kimliklerine bağlı olabilir. Özellikle, hesaplama sisteminin durumuna ait bir bileşen, belirli bir nesneyle benzersiz şekilde ilişkilendirilebilir. Genel olarak, böyle bir bu durum nesnenin katıldığı belirli talepler bildirilmeden değiştirilemez. Başka bir deyişle, farklı nesneler işlemler tarafından kapsüllenmiş ayrı bir duruma sahip olabilirler.</p>
<blockquote>Bu ifadeler, hesaplama sisteminin kastedilen gücünü tanımlamaktadır. Belirtilen özelliklerle nesneleri tanımlamak mümkün olmalıdır. Kapsüllenmiş durumun klasik örneği, push (ekle) ve pop (kopar) hizmetlerini sunan yığın nesnesidir: örtülü olarak bir yığın nesnesi ile ilişkilendirilen durum, push (eklenen) edilen ama henüz pop edilmemiş (koparılmamış) öğelerin sırasıdır. Bu durum yalnızca push ve pop işlemleri ile değiştirilir. İstemcilere sadece pop’un zamanla değişen davranışıyla gösterilir.</blockquote>
<blockquote>Hesaplama sisteminin durumunun tek tek nesnelerle benzersiz şekilde ilişkilendirilmemiş ek bileşenleri olabilir. Örneğin, iki nesne kümesi, program kaynağı ve geliştirici nesneleri üzerinde yaratılmış ve tarafından-yaratılmış ilişkilerini düşünün. Bu işlemlerle sunulan durumun, nesne çiftleriyle veya işlemlerin alternatif olarak kendileriyle ilişkilendirildiği düşünülebilir. İlişkilendirilmiş durum denildiğine, durumun kalıcı gösteriminin şeklini sınırlandırmak kastedilmemektedir.</blockquote>
<blockquote>Nesne modeli, nesne yaratımı ve nesne yokedilmesi konusunda başka detaylar tanımlamamaktadır.</blockquote>
<h4>3.5 Soyut Nesne Kimliği</h4>
<p>Nesneler, isteklerin davranışını etkiledikleri ölçüde istemciler tarafından ayırt edilebilme yeteneğine sahiptirler.</p>
<blockquote>Diğer bir deyişle, nesne modeli, yukarıda tanımlandığı gibi nesne kimliğinin istemcilere doğrudan ifşa edilmesine izin verir ancak bu durumu zorlamaz. Nesne kimliği ile ilgili istemciler için uygun olan aşağıda gösterilen şekilde diğer olası kavramlar da vardır. Nesne modeli tarafından desteklenmese dahi, sistemin soyutlama yeteneklerinin, nesne kimliği ile ilgili soyut kavramların sağlanarak kullanılması mümkün olabilir. Bu kavramlar, istemciler tarafından talep edilen belirli hizmetler şeklinde gerçekleştirilebilirler. Örneğin, soyut bir nesne kimliği kavramına göre iki nesnenin kimliğinin “aynı” olup olmadığını karşılaştıran bir bir hizmet sunulabilir. Kastedilen soyut nesne kimliği kavramını temel alarak, hizmet, ayrık bir biçimde yaratılmış iki nesnenin “aynı” olduğunu bildirebilir. Nesne modeli, bu tarz bir hizmeti tanımlamamaktadır. Böyle bir hizmetin uygulanımını yapmak, nesnelerin ayrık bir şekilde yaratılmalarına göre test edilebilmelerini gerektirir.</blockquote>
<blockquote>Nesne kimliği konusuna daha soyut bir fikir örneği vermek gerekirse, “Kimlik birleştirme” kavramından bahsedilebilir. Bu fikir aslında birbirinden ayrık olan iki nesnenin, istemcilerin görüş açısından birbirinden ayılamayan, tek bir nesne haline gelmelerine izin verir. Nesneler gerçek dünyanın evrimleşen bir şekilde anlaşılması anlamında, dünyayı modellemek için kullanıldığında, örneğin, “Joe’nun babası” ve “Bob’un kardeşi” varlıklarının aslında aynı kişi olduğunu belirten bir modelleme için kullanıldığında faydalı olmaktadır.</blockquote>
<blockquote>Nesne kimliği fikri için daha soyur bir örnek (değişmez) matematiksel soyutlamalardır. Elemanları 1 ve 2 tamsayılarından oluşan bir küme kavramını matematiksel soyutlamaya örnek olarak verebiliriz. Bu şekilde sadece tek bir küme vardır. Nesneleri matematiksel soyutlamaları temsil etmek için kullanan bir sistemde, aynı soyutlamayı temsil etmek için birbirinden farklı çoklu nesneler var olabilir. Fakat, istemciler, bu nesneleri “özdeş” olarak görmelidirler. Bir hizmet, istemciler için bu ilüzyonu sağlayabilecek şekilde tanımlanabilmelidir.</blockquote>
<blockquote>Soyut nesne kimliğini desteklemek için gereken motivasyon, nesne modelinde doğrudan daha karmaşık kimlik biçimleri sağlamak yerine, yeni kimlik kavramlarını tanımlamadaki esnekliği sağlamak ve nesne teknolojisinin uygulanımları çok zor olan nesne kimliği kavramlarını desteklemesini önlemektir. Daha karmaşık nesne kimliği biçimleri, belirli bir nesne modelinde önlenmiş değildir.</blockquote>
<h4>3.6 Anlamlı talepler</h4>
<p>Tüm talepler anlamlı değildir: bir nesne, tüm hizmetleri desteklemek durumunda olmayabilir ve bir talebin mevcut öz niteliklerinde başka kısıtlamalar varolmuş olabilir.</p>
<blockquote>Anlamlı talep fikri, tip tabanlı sistemlerde, tiplerin hatasızlığı fikrine karşılık gelmektedir. Smalltalk’daki mesaj anlaşılamadı hataları bu fikre karşılık gelmektedir.</blockquote>
<p>Her işlemin, o işlem için anlamlı olan olası (mevcut) öz nitelik değerlerini kısıtlayan ilişkili imzası vardır. Mevcut öz nitelikleri talep içinde tanımlanmış işlem imzasını tatmin etmeyen bir talep, anlamsızdır. Anlamsız bir talep bildirimi yapmak, istemciye bir istinsa koşulu rapor edilmesine yol açabilir.</p>
<blockquote>Tip tabanlı programlama dillerine aşina olan okuyucular için, bir imza, bir prosedür veya fonksiyon tipi gibidir. Bu özel durumda, bir imza, (birden fazla türe sahip argümanları kabul eden) jenerik bir fonksiyonun türü gibidir. Örneğin, artı işleminin imzası, mevcut argümanların gerçel sayı veya tamsayıların bileşkesi olduğu ve bir tamsayı sonucunun eğer iki parametre de tamsayı olduğu (ya da gerçel sonucun iki parametre de gerçek olduğu), iki adet öz nitelik olmasını şart koşuyor olabilir.</blockquote>
<blockquote>Nesne Modeli, dilin imzalar tanımlamak zorunda olup olmadığını tanımlamamaktadır. Bu tarz bir nesne modelinin detaylanmış hali, belirli imza biçimlerini tanımlayabilir.</blockquote>
<blockquote>Eğer işlem isimleri (işlem isimlerinin talepler içinde öz nitelik olabildiği durumlar) değerler ise, imzalar aşağıda tanımlandığı gibi tip olarak düşünülebilir. Bu manada, Figür 1, işlemlerin tiplere sahip olduklarını göstermektedir.</blockquote>
<p>Bir işlem yaratıldığında, imzası da belirlenmiş olur.</p>
<blockquote>Nesne modeli bir işlemin yaratıldıktan sonra imzasını değiştirip değiştiremeyeceğini tanımlamamaktadır.</blockquote>
<p>Bir imza, ilgili talepler ile ilişkili olan olası sonuç değerlerini veya istisnai koşulları karakterize edebilir. Bu ek bilgi, anlamlı talep fikrini etkilememektedir, ancak programların statik analizlerini gerçekleştiren araçlar tarafından kullanılabilir.</p>
<blockquote>Nesne modeli, sonuçların olası karakterizasyonlarını tanımlamaz. Tipik olarak, sonuçları kendi tipleri açısından imzalar karakterize etmektedir. İmzalar işlem davranışının biçimsel veya biçimsel olmayan tanımları veya işlemin eşzamanlı olup olmadığı gibi ek bilgiler içerebilirler.</blockquote>
<p>Bir tip, olası sonuçları karakterize eden veya olası öz nitelikleri kısıtlamaya yarayan bir imzada kullanılabilecek değerler üzerinde tanımlanmış (boolean fonksiyonu biçiminde olan) bir beyan biçimidir.</p>
<blockquote>Bu açıklama, tip fikrine ilişkin çok genel bir tanım belirtmektedir. Bu tanıma göre, tamsayı gibi bir tür, bir tamsayı değerine uygulandığında true döndüren ve başka herhangi bir değere uygulandığında false döndüren bir işlem olarak düşünülebilir. Bu tanım, tek sayılar türü gibi daha alışılmadık türler tanımlanmasına olanak verir. Bu tanımın, tek bir değerin birden fazla türde olmasını (birden fazla tür işlemlerini tatmin edebilmesini) sağladığına dikkat edin. Örneğin, 1 numaralı tamsayıyı ifade eden değer, hem bir tam sayı, hem de tek bir tamsayıdır.</blockquote>
<blockquote>Nesne modeli, bir sistemde hangi tür tiplerin var olabileceğini tanımlamamaktadır. Bu modelin ayrıntılı bir şekilde ele alınması, türler için belirli bir biçimselliği tanımlayacaktır. Biçimselliğin seçimi, tip olarak kullanılabilecek işlem (predicate) kümesini kısıtlayabilir.</blockquote>
<blockquote>Tip kavramının bu tanımı, aynı nesneyi (veya başka bir soyut varlığı) belirten farklı değerleri birbirinden ayırmayı sağlayan tiplere olanak verir. (fakat zorunlu kılmaz.) Eğer belirli bir nesne modeli, aynı nesneyi (veya başka bir soyut varlığı) tanımlayan değerleri birbirinden ayırmaya yarayan tipleri sağlamıyorsa, tipler, (değerler üzerinde varolan işlemlerden hariç olarak) nesneler üzerinde varolan işlemler (predicate) olarak görülebilirler.</blockquote>
<blockquote>Hali hazırda varolan nesne-yönelimli programlama dilleri, sınıf adı verilen, nesnelerin birbirinden farklı uygulanımlarını birbirinden ayırmaya yarayan tipler sunmaktadırlar. Arayüz tipinin daha genel bir kavramı, jenerik işlemleri sezmeyi sağlayan alttaki açıklamada bulunmaktadır.</blockquote>
<blockquote>Nesne model, tiplerin nesneler veya çağırılabilen işlemler olup olmadıklarına bir kısıtlama getirmemektedir. Bazı sistemlerde, tip-kontrolü derleme zamanında gerçekleştirilir ve tipler çalıştırma sırasında temsil edilmezler.</blockquote>
<p><em>Bir tipin genişletilmesi (extension), </em>belirli bir tipi tatmin eden değerlerin kümesidir. Bir tipin genişletilmesi, yeni nesneler yaratıldığı sürece, zamana bağlı olarak değişebilir ve varolan nesneler üzerinde yan etkilere sebep olabilir.</p>
<blockquote>Eğer tipler, aynı nesneyi tanımlayan birden çok değerleri ayırt etmiyorlarsa, tip genişletilmesi, değerlerin kendilerinden hariç olarak, sunulan değerler tarafından tanımlanan nesnelerin içerilmesi olarak görülebilir.</blockquote>
<p>Bir ilişki, tipler üzerinde tanımlanan uygunluk olarak adlandırılmaktadır. Eğer a tipine uyumlu olan herhangi bir değer, b tipine de uyumluysa, a tipi, b tipine uyumludur.</p>
<blockquote>Uyumluluk ilişkisini tanımlayacak olan belirli bir nesne modeli, mantıksal düşünce ile uyumlu olmalıdır. Uyumluluk, kalıtımın geleneksel kullanımlarından biri olan, nesnelerin hiyerarşik bir şekilde sınıflandırılmalarına olanak verir. Tip uyumluluğuna aşağıda bir örnek verilmektedir.</blockquote>
<p>Bir <em>nesne tipi</em>, tip genişlemesinin bir nesneler kümesi olduğu tip çeşididir. (Tam olarak nesneleri tanımlayan değerler kümesidir.) Diğer bir deyişle, bir nesne tipi, sadece nesneler (nesneleri tanımlayan değerler) tarafından tatmin edilebilir.</p>
<blockquote>Bir nesne birden çok tipi tatmin edebilir. Örneğin, bir Lotus 2.2 tablo nesnesi, (azalan belirginlikle) şu tipleri tatmin sırayla tatmin etmektedir: Lotus 2.2 tablosu, Lotus tablosu, yazdırılabilir nesne. Bu örnekte, bütün tipler uyumluluklarına göre ilişkilidirler. Bazı sistemler, bir nesnenin uyumlulukla alakalı olmayan tipleri tatmin etmesine olanak sağlayabilir. Örneğin, belirli bir bireyi tanımlayan bir nesne, kişi tipini ve hissedar tipini birlikte tatmin edebilir. (Hissedar olmayan kişiler veya kişi olmayan, örneğin, şirket olan hissedarlar var olabilir.)</blockquote>
<p>Bir arayüz, nesnenin olası kullanımlarının kümesininin tanımıdır. Özellikle, bir arayüz, bir nesnenin anlamlı bir şekilde katılabileceği olası talep kümesini tanımlar. Bir nesne, arayüz tarafından tanımlanan her bir talep için anlamlı olması ile arayüzü <em>tatmin eder</em> denir.</p>
<blockquote>Klasik nesne sisteminde, bir arayüz işlemler kümesinden oluşur. Örneğin, “yazdırılabilir nesneler” arayüzü, tek bir <em>yazdır</em> işleminden oluşabilir. Bir nesne, bu işlemlerden birini tanımlayan herhangi bir talebin ilk parametresi olarak anlamlıysa, klasik bir nesne arayüzünü tatmin eder denir.Genelleştirilmiş nesne modelini destekleyen bir sistem, nesnenin anlamlı olarak ortaya çıkabildiği işemlerin belirli biçimsel parametrelerini tanımlayan daha karmaşık arayüzleri destekleyebilir. Örneğin “yazdırılabilir nesne” arayüzü, yazdır talebinin ilk parametresi olarak görünen ve “yazıcı nesnesi” arayüzü, yazdır talebinde ikinci öz nitelik olarak ortaya çıkan bu nesneler tarafından tatmin ediliyor olabilir.</blockquote>
<blockquote>Arayüzler bir anlamda, imzaların ikilileridir. Taleplerin anlamlılığını belirleyen “kısıtlamalar” kümesi içeren, bir sistem düşünülebilir. İmzalar, bu bilginin işlem-merkezli görüşüdür ve arayüzler, bu bilginin nesne-merkezli görüşüdür. Nesne modeli, bu bilginin nereden kaynaklandığını belirlemez. Bir nesne, yazdır işleminin davranışını tanımladığı için yazdırılabilir olabilir. Alternatif olarak, bir nesne, yazdır işleminin beyan edilen ilk argümanın tipi olan yazdırılabilir nesneyi tatmin ettiği varsayıldığı için yazdırılabilir olabilir.</blockquote>
<p>Bir arayüz tipi, herhangi bir nesne (harfi harfine nesneyi tanımlayan bir değer) tarafından tatmin edilebilen bir tiptir.</p>
<blockquote>Bir arayüz, belirli bir nesnenin ne yapabileceğini ve istemcinin nesneyi nasıl kullanma niyetinde olduğunu aynı anda tanımlayabilir. Örneğin, bir arayüz tipi, bir prosedür için biçimsel öz niteliği bildirmek, mevcut öz nitelik nesnesinin prosedür içerisinde nasıl kullanılacağını göstermek için kullanılabilir.</blockquote>
<blockquote>Arayüz tipleri üzerinde uyumluluk küçük bir arayüz tarafından nasıl kullanılacağı açıklanan bir objenin, aynı zamanda daha büyük bir arayüz tarafından tanımlandığı şekilde kullanılabilmesi anlamına gelir. Arayüz tipleri üzerinde uyumluluk en azından basit tip sistemleri için, küme içermesi ile ilişkilidir. Yazdır ve Kopyala işlemlerinden oluşan arayüz, sadece yazdır işlemini içeren arayüzle, yazdırılabilen ve kopyalanabilen (içermeden dolayı) bir nesne basitçe yazdırılabildiği için uyumludur.</blockquote>
<p>Her bir nesnenin, nesne için anlamlı olan bütün talepleri açıklayan esas (azami, en genel) bir arayüzü vardır.</p>
<blockquote>Bir nesnenin esas arayüzü, yeni işlemler tanımlanması gibi belirli sebeplerden dolayı genişleyebilir veya daralabilir. Nesne modeli, istemsinin bir nesnenin esas arayüzünü belirleyebildiği bir hizmetin varlığına izin verir ama bunu zorlamamaktadır.</blockquote>
<h4>4. Nesne Uygulanımı</h4>
<p>Bu bölüm, nesne uygulanımı ile ilgili kavramları, örneğin, nesnelerin uygulanımı ile ilgili kavramları tanımlar. (Bkz. Şekil 3.)</p>
<h4>4.1 Taleplerin Gerçekleştirilmesi</h4>
<p>İstenen bir hizmeti gerçekleştirmenin pratik etkisi depolanan bazı verilere erişen bazı kodların çalıştırılmasına neden olmaktır. Saklanan veriler, hesaplama sisteminin durumunun bir bileşenini temsil eder. Talep edilen hizmeti gerçekleştiren kod, sistemin durumunu durumunu değiştirebilir. Bir hizmeti gerçekleştirmek için yürütülen koda bir metod (yöntem) adı verilir.</p>
<p>Bir NYG sistemi, istemciler ve hizmetler arasındaki arabulucu olarak görev yapan bir altyapı içermektedir. (Tabii ki, bir hizmet kendi isteklerini yayınlayarak da bir istemci olabilir.) Altyapının birincil işlevi, istenen bir hizmeti gerçekleştirmek için uygun kodu seçmek ve bu kodu uygun verilere erişmek için çalıştırmaktır.</p>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/01/0985c-13cqm0oktijx6olypi9qs6w.png">

<figcaption class="wp-caption-text">Nesne uygulanımının ana kavramları</figcaption></figure><p>Talep edilen bir hizmeti gerçekleştirmek ve metod tarafından erişilecek veriyi seçmeye bağlama (binding) denir. Bağlama, (tipik olara bir metodun) seçiminin, mevcut talep bildirilmeden önce olursa statik, veya seçim talep bildiriminden sonra yapılıyorsa dinamik olarak adlandırılır.</p>
<blockquote>Statik bağlama, bildirimlere bağlı olarak derleyiciler tarafından gerçekleştirilir. Talep bildiren bir program yapısı genellikle değişkenler içerir. Programdaki bildirimler, bu değişkenler tarafından ifade edilen olası değerleri kısıtlayabilirler.</blockquote>
<p>Talep edilen bir hizmeti gerçekleştirilen kod belirli etkenlere, özellikle talebe katılan nesnelerin kimliğine bağlı olabilir.</p>
<blockquote>Katılan nesnelere bağlı olan kod seçimi, bir işlemin jenerik olarak açıklanmasına temel oluşturur. Klasik bir nesne modelinde, seçilen kod, sadece bir talebin ilk öz niteliği tarafından tanımlanan nesne sınıfı ve işleme bağlıdır.</blockquote>
<blockquote>Seçilen kod ayrıca, nesnenin “konumu” veya istemcinin “konumu” gibi diğer etkenlere de bağlı olabilir. (Nesne modeli bir konum kavramını zorunlu kılmamaktadır.) Belirli bir nesne teknolojisi istemciler için artırılmış bir öngörülebilirlik sağlayan bağlama işlemi üzerinde kısıtlamalar empoze edebilir. NYG modeli, kasıtlı olarak bunun gibi kısıtlamalar empoze etmemektedir.</blockquote>
<p>Talep edilen bir hizmetin gerçekleştirilmesi, kaydedilmiş bir veriye erişebilen bir metodun çalıştırır. Eğer metodun ve verinin kalıcı biçimi çalıştırılamıyorsa, önce çalıştırılamayan metodu ve veriyi, çalıştırılabilir bir adres alanına kopyalamak gerekli olabilir. Bu işleme <em>aktivasyon</em> denir. Bunun tersini yapan işleme ise <em>pasifleştirme</em> denir.</p>
<h4>4.2 Davranışın gerçekleştirilmesi</h4>
<p>Bir NYG sistemi, taleplerin davranışlarının gerçeğe dönüştürülmesini sağlayan mekanizmaları sunmak zorundadır. Bu mekanizmalar, veri yapısı tanımları, metod tanımlamaları ve NYG altyapısının çalışacak metodların ve metodlar için erişilebilir hale getirilen verilerin seçiminin nasıl yapılacağının tanımlamalarını içerebilir. Mekanizmalar ayrıca yeni verilerin tahsis edilmesi ve nesnenin uygun metodlarla ilişkilendirilmesi gibi, nesne yaratımı ile ilgili olan somut eylemleri tanımlamak için sağlanmak zorundadırlar.</p>
<p>Bir nesnenin uygulanımı -ya da kısaca uygulanım- nesnenin yaratılması ve nesnenin uygun hizmet kümesine katılımını sağlayan bilgilerin tanımlanmasıdır. Bir uygulanım, tipik olarak, bir nesneyle ilişkili olan çekirdek durumu temsil eden veri yapısının tanımını ve bunun yanısıra bu veri yapısına erişen metodların açıklamalarını içerir. Ayrıca, tipik olarak, nesnenin niyet edilen tipi hakkında bilgi içerir. (Bir uygulanım, varolan bir nesneye yeni davranışlar eklemek için de kullanılabilir.)</p>
<p>Bir NYG sistemi, metod tararından gerçekleştirilmekte olan hizmet için varolan talebin içinde tanımlanan nesne veya nesnelere referans veren metod tanımlarına izin veriyor olabilir. Kendine-referans olarak adlandırılan bu yetenek, bir metodun, aynı nesne ya da nesneleri dahil eden ek taleplerde bulunmasına olanak verir. Kendine-referans, tek bir metod, farklı nesneler tarafından çalıştırılabildiğinde yararlıdır. (Smalltalk’ta kendine-referans self kelimesi ile gösterilir.)</p>
<h4>4.3. Davranışın paylaşılması</h4>
<p>Bir NYG sistemi, tipik olarak, uygulanımı paylaşan aynı davranışa sahip olan nesnelere izin veren mekanizmaları sağlayacaktır. Bir sınıf, birden fazla nesnenin yaratılması için örneklenebilen (instantiated) uygulanımdır. Sonuç olarak ortaya çıkan nesnelere, sınıfın örnekleri denir. Kendine-referans, bir sınıfın birden çok örneği, metodları paylaştığında yararlıdır.</p>
<p>Ancak, aynı davranışı destekleyen birbirinden farklı uygulanımlar da olabilir. Örneğin, belirli bir donanım ortamı için belirli uygulanımlar mevcut olabilir. Ayrıca, zamanla, performans artırımı için sunulmuş olan uygulanım serileri de mevcut olabilir.</p>
<blockquote>Çoğu varolan sistemde, sınıflar, uygulanımı ve arayüz tipini birlikte tanımlamaktadırlar. Bu görevleri tek bir varlıkta birleştirmek, bir sistemin aynı davranışın farklı uygulanımlarını desteklemesini zorlaştırabilir. Bir sınıf, bir nesne olabilir veya olmayabilir.</blockquote>
<p>Bir NYG sistemi, tipik olarak kendi uygulanımlarının bazı kısımlarını ortak kullanan benzer davranışlara sahip nesnelere izin veren mekanizmalar sunacaktır. Örneğin, bir uygulanım kalıtımı, bir uygulanımın artımlı bir şekilde düzelmesi olarak tanımlanan uygulanıma izin vermek için sağlanıyor olabilir.</p>
<p>Uygulanımların ortak kullanımını sağlayan alternatif bir teknik delegasyondur. Delegasyon, talebi gerçekleştiren metodun içindeki kendine referansın, talebi bildiren metodda kendine referans olarak aynı nesne veya nesneleri döndürebilmesi yeteneğidir.</p>
<h4>5. Sözlük</h4>
<p><strong>Aktivasyon:</strong> (activation) Metodların ve kaydedilmiş verinin kalıcı biçiminin, çalıştırılabilir bir adres alanına, metodların, kaydedilmiş veriler üzerinde çalışmalarını sağlamak için kopyalanması.<br><strong>Davranış: </strong>(behavior)<strong> </strong>Bir talebin davranışı, talep edilen hizmetin (sonuçları içerecek şekilde) yarattığı gözle görülebilen etkileridir. (Bakınız sonuçlar.)<br><strong>Bağlama:</strong> (binding.) Talep edilen hizmeti gerçekleştirmek için varolan kodun ve kod tarafından erişilecek verinin seçilmesi. (Bakınız metod)<br><strong>Sınıf:</strong> (class) Bir sınıf, aynı (başlangıç) davranışa sahip olan nesnelerin yaratılması için örneklenebilen uygulanımdır.<br><strong>İstemci: </strong>(client) Bir istemci hizmet talep edebilen herhangi bir hesaplama varlığıdır.<br><strong>Uygunluk:</strong> (conformance) Uygunluk, mantıksal düşünüşle uyumlu olan tipler üzerinde tanımlanmış olan ilişkidir. A tipini tatmin edenherhangi bir değer, aynı zamanda b tipini de tatmin ediyorsa, bir a tipi, b tipine uygundur denir.<br><strong>Dinamik Bağlama:</strong> (dynamic binding) Talep bildirildikten sonra gerçekleştirilen bağlama işlemidir.<br><strong>Delegasyon:</strong> (delegation) Delegasyon, talebi gerçekleştiren metodun içindeki kendine referansın, talebi bildiren metodda kendine referans olarak aynı nesne veya nesneleri döndürebilmesi yeteneğidir. (Bakınız kendine-referans)<br><strong>Kapsüllenmiş:</strong> (encapsulated) Bir nesne, ilişkili olduğu durum sadece belirli metodlar tarafından erişilip değiştirilebiliyorsa, kapsüllenmiştir.<br><strong>Tipin genişlemesi:</strong> (extension of a type) Bir tipin genişlemesi, tipi tatmin eden değerler kümesidir.<br><strong>Jenerik işlem:</strong> (generic operation) Kavramsal düşünce. Bir işlem, gözle görülür farklı davranışlara yol açan, farklı uygulanımlara sahip nesnelerden talep edilen bi hizmeti tanımlıyorsa jeneriktir denir.<br><strong>Tutamaç:</strong> (handle) Tutamaç, nesneyi güvenilir bir şekilde tanımlayan bir değerdir. (Bakınız nesne adı)<br><strong>Kimlik:</strong> (identity) Kavramsal düşünce. Bir varlık doğası gereği diğer varlıklardan ayır edilebiliyorsa, (örneğin ayrık yaratım olayları temelinde) bir kimliğe sahiptir denir.<br><strong>Uygulanım:</strong> (implementation) Bir uygulanım, bir nesnenin yaratımı ve nesnenin uygun olan hizmet kümesini sunmadaki katılımı için gerekli olan bilgiyi sağlayan açıklamadır. Bir uygulanım, tipik olarak, bir nesneyle ilişkili olan çekirdek durumu temsil eden veri yapısının tanımını ve bunun yanısıra bu veri yapısına erişen metodların açıklamalarını içerir. Ayrıca, tipik olarak, nesnenin niyet edilen tipi hakkında bilgi içerir.<br><strong>Uygulanım kalıtımı:</strong> (implementation inheritance) Diğer uygulanımların artımlı bir şekilde düzeltilmesiyle meydana gelen uygulanım yapısı.<br><strong>Kalıtım:</strong> (inheritance) Diğer tanımlamaların artımlı bir şekilde düzeltilmesiyle meydana gelen tanımlama yapısı. (Bakınız uygulanım kalıtımı)<br><strong>Örnek:</strong> (instance) Bir sınıfın örneklenmesiyle yaratılan nesne.<br><strong>Örnekleme:</strong> (instantiation) Bir sınıf kullanarak bir nesne yaratma işlemi.<br><strong>Arayüz:</strong> (interface) Bir arayüz, nesnenin olası kullanımlarının kümesini tanımlamasıdır. Özellikle, bir arayüz, bir nesnenin, anlamlı olarak katılım sağlayabildiği olası talepleri tanımlar.<br><strong>Arayüz tatmini:</strong> (interface satifaction) Bir nesne, arayüz tarafından tanımlanmış her bir olası talep için anlamlı ise bir arayüzü tatmin eder.<br><strong>Arayüz tipi:</strong> (interface type) Bir arayüz tipi, belirli bir arayüzü tatmin eden her nesne tarafından tatmin edilen tiptir. (Bakınız nesne tipi)<br><strong>Sabit:</strong> (literal) Nesne olmayan bir varlığı tanımlayan değer. (Bakınız nesne adı)<br><strong>Anlamlı:</strong> (meaningful) Bir talep, mevcut öznitelikleri, söylenen işlemin imzasını tatmin ediyorsa, anlamlıdır.<br><strong>Metod:</strong> (method) Talep edilen bir hizmeti gerçekleştirmek için çalıştırılabilen kod.<br><strong>Nesne:</strong> (object) Bir NYG nesnesi, NYG hesaplama sisteminde, ayrılmış bir varlık tipidir.<br><strong>Nesne Yaratımı:</strong> (object creation) Bir nesnenin daha önce varolan nesnelerden farklı olacak şekilde varolmasını sağlayan olay.<br><strong>Nesne Uygulanımı:</strong> (object implementation) Bakınız uygulanım.<br><strong>Nesne Adı:</strong> (object name) Bir nesneyi tanımlayan değer. (Bakınız tutamaç)<br><strong>Nesne Tipi:</strong> (object type) Bir nesne tipi, genişlemesinin bir nesneler kümesi (harfi harfine nesne tanımlayan değerler kümesi) olduğu bir tiptir. Diğer bir deyişle, bir nesne tipi, sadece nesneler (nesneyi tanımlayan değerler) tarafından tatmin edilir. (Bakınız arayüz tipi)<br><strong>İşlem:</strong> (operation) Bir işlem, talep edilebilen tanımlanmış bir hizmettir. Bir işlemin ilişkili olduğu, anlamlı bir talep içerisindeki öz nitelikleri kısıtlayabilen bir imzası vardır.<br><strong>İşlem adı:</strong> (operation name) Bir işlemi tanımlamak için bir talep içerisinde kullanılan isim.<br><strong>Katılmak:</strong> (participate) Bir nesne, talebin bir veya birden fazla özniteliği, o nesneyi tanımlıyorsa, talebe katılır.<br><strong>Pasifleştirme:</strong> (passivation) Aktivasyonun tersi.<br><strong>Esas arayüz:</strong> (principal interface) Bir nesnenin esas arayüzü, nesnenin anlamlı olduğu bütün talepleri tanımlayan arayüzdür.<br><strong>Talep:</strong> (request) Talep bir olaydır. Bir istemci, bir hizmetin gerçekleştirilmesi için talep bildiriminde bulunudur. Bir taleple ilişkili olan bilgi, sıfır veya daha fazla (mevcut) öz nitelikten oluşur. Ayrıca, istemciye dönebilecek olan sonuçlar da taleple ilişkilidir.<br><strong>Sonuçlar:</strong> (results) Bir talebin sonuçları, istemciye geri dönen, talep edilen hizmetin gerçekleştirilmesi sırasında ortaya çıkan istisnai koşulları gösteren durum bilgisi gibi değerleri içerebilen bilgidir. <br><strong>Kendine-referans:</strong> (self-reference) Kendine referans, bir metod tarafından gerçekleştirilmekte olan hizmet talebinde tanımlanan nesne ya da nesnelerin, metod tarafından saptanması yeteneğine denir. (Smalltak’da kendine referans self kelimesiyle gösterilir.) (Bakınız delegasyon)<br><strong>Hizmet:</strong> (service) Bir hizmet, talebe bağlı olarak gerçekleştirilebilen hesaplamadır.<br><strong>İmza:</strong> (siganture) Bir imza, işlemi adlandıran taleplerde anlamlı olan, olası (mevcut) öz nitelik değerlerinin kısıtlandığı işlem tanımıdır. Mevcut öz niteliklerinin talepte adlandırılmış işlem ile ilişkili olan imzayı tanımlamadığı talepe, anlamsız talep denir.<br><strong>Durum:</strong> (state) Bir hesaplama sisteminin durumu, gelecek taleplerin davranışını açıklamak için ihtiyaç duyulan eski taleplerin tarihçesi hakkındaki bilgidir.<br><strong>Statik Bağlama:</strong> (static binding) İstemcisinin statik özelliklerine bağlı olarak, talebin bildirilmesinden önce gerçekleştirilmiş bağlama işlemidir.<br><strong>Tip:</strong> (type) Tip, olası bir sonucu karakterize eden veya, olası öz nitelikleri kısıtlayan imzada kullanılabilen değerler üzerinde tanımlanan işlemdir. (predicate) (boolean fonksiyonu)<br><strong>Değer:</strong> (value) Bir değer, bir talepte olası mevcut değer olabilen herhangi bir varlıktır. Nesneleri tanımlamaya yarayan değerler, nesne adı olarak adlandırılır. Nesneler dışındaki varlıkları tanımlayan değerler, sabit olarak adlandırılır. (literals)</p>
<h4>Referanslar</h4>
<p>[1] D. H. Fishman, et al. Iris: An Object-Oriented Database Management System. ACM ‘Iransactions on Office Information Systems, 5:1 (Jan. 1987). <br>[2] S. Keene. Object-oriented programming in Common Lisp. Symbolics Press and AddisonWesley, 1989. <br>[3] A. Snyder. The Essence of Objects. Report STL-89–25, Hewlett-Packard Laboratories, Palo Alto, California, 1989.</p>
<hr>

<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2016/12/cceb0-14uozfs7kywroi5ep-uyz5g.jpeg">

<figcaption class="wp-caption-text"><em>Projelerle PHP 7</em></figcaption></figure><p><em>Ben </em><a href="http://mynameismidori.com" target="_blank"><strong><em>Mutlu Koçak</em></strong></a><em>, Bilgisayar Mühendisiyim, ZCPE Sertifikasına sahibim ve “</em><a href="https://www.seckin.com.tr/kitap/911934237" target="_blank"><em>Hiç Bilmeyenler İçin İnternet Programlamaya Giriş — PHP 7</em></a><em>” adlı kitabın yazarıyım. Kitabım: </em><a href="https://www.seckin.com.tr/kitap/911934237" target="_blank"><em>https://www.seckin.com.tr/kitap/911934237</em></a><em><br>Özgeçmişim: </em><a href="http://represent.io/mtkocak.pdf" target="_blank"><em>http://represent.io/mtkocak.pdf</em></a><em> <br>Websitem: </em><a href="http://mynameismidori.com" target="_blank"><em>http://mynameismidori.com</em></a></p>