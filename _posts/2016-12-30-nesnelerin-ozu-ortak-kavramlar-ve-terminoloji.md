---
ID: 74
post_title: >
  Nesnelerin Özü, Ortak Kavramlar ve
  Terminoloji
author: Midori Kocak
post_excerpt: ""
layout: post
permalink: >
  https://www.meraklibilisimci.com/nesnelerin-ozu-ortak-kavramlar-ve-terminoloji/
published: true
post_date: 2016-12-30 16:25:35
---


<h4>Alan Snyder, Yazılım ve Sistemler Laboratuvarı HPL-91–50 Haziran, 1991 Çeviri: Midori Koçak — mtkocak (at) gmail (dot) com 25.12.2016</h4>
<figure>

<img src="https://cdn-images-1.medium.com/max/800/0*2l2ulHGvYExKi5V_.">
</figure><p>Anahtar kelimeler: Nesneler, nesne-yönelimli-programlama, nesne-yönelimli-veritabanları, nesne-yönelimli kullanıcı arayüzleri, dağıtık sistemler, terminoloji</p>
<p>İlk başta nesne-yönelimli programlama dilleri için geliştirilmiş olan kavramlar birçok farklı alanda da gözümüze çarpıyorlar. Bunlar, nesne-yönelimli veritabanları, nesne-yönelimli uygulama ve birleşik platformlar, ve hatta nesne-yönelimli kullanıcı arayüzleridir. Nesne kavramları, dağıtık sistemlerde genişçe kullanıldılar ve açık sistemlerin yönetimi için olan taslak ISO Standartlarında belirgindirler. İnanıyoruz ki, “Nesne” kavramlarını gözden geçirirken, bu gibi sistemlerin çoğunda veya tamamında ortaya çıkan önemli kavramları da tanımlamış oluyoruz.</p>
<p>Ortak bi terminolojinin olmaması yüzünden ortak kavramları tanımlamak daha da zorlaşıyor. Ortak terminolojinin olmaması, araştırmacılar, geliştiriciler ve kullanıcılar arasındaki iletişime de engel olmakta. Bu raporda, sadece programlama dilleri için değil, bir çok alanda genişçe uygulanabilmesi için seçilmiş nesne kavramları için ortak bir terminoloji önermekteyiz. Önemli kavramları tanımlayacak, örneklere verecek ve anahtar terimleri belirleyen bir sözlük de sunacağız.</p>
<h4>1. Giriş</h4>
<p>Asıl olarak nesne-yönelimli programlama dilleri için geliştirilmiş kavramlar, birçok farklı alanda da ortaya çıkmaktadılar. Bunlar, nesne-yönelimli veritabanları, nesne-yönelimli uygulama çerçeveleri ve birleşik platformlar ve hatta nesne-yönelimli kullanıcı arayüzleridir. Nesne kavramları, dağıtık sistemlerde genişçe kullanıldılar ve açık sistemlerin yönetimi için olan taslak ISO Standartlarında belirgindirler.</p>
<p>Bu alanlar neyin nesne nesne-yönelimli olup olmadığını gösteren ortak bir kavramı paylaşıyorlar mı? İnanıyoruz ki, “Nesne” kavramlarını gözden geçirirken, bu gibi sistemlerin çoğunda veya tamamında ortaya çıkan önemli kavramları da tanımlamış oluyoruz.</p>
<p>Bu kavramları, bir sizi açıklayıcı cümleyi içeren tabloyla göstereceğiz. Her açıklama, çeşitli alanlardan gelen örneklerle gösterildiler. Örnekler, Smalltalk, C++ ve Common Lisp Nesne Sistemi (programlama dilleri), HP Yeni Dalga Ortamı (kişisel bilgi işlem için bir uygulama entegrasyonu ortamı), Xerox ViewPoint (Ofis İş İstasyonu), HP SoftBench uygulama geliştirme ortamı (yazılım geliştirme araçları için entegrasyon çerçevesi), Iris (veritabanı sistemi), Symbolic Dynamic Windows (kullanıcı arayüzü) ve açık sistemlerin yönetimi için uluslarası ISO taslak standardını kaynak alıyorlar. Bu sistemler az ya da çok nesne-yönelimli olarak ifade edilen sistemlerdir.</p>
<p>Anlatmaya yardımcı olmak için, bu sistemlerin olası faydalarını, nesne-yönelimli olmayan çözüm örnekleriyle karşılaştıran örnekler vereceğiz. Burada amacımız, nesne-yönelimli yaklaşımın değerini anlatmak değil, onu açıklamaktır. Dengeli bir değerlendirme için gereken karşı argümanları geçiyoruz. Okuyucu, alternatif yaklaşımların avantajlarının olmadığını düşünmemelidir.</p>
<p>Ortak bi terminolojinin olmaması yüzünden ortak kavramları tanımlamak daha da zorlaşıyor. Birbirinden farklı bir çok ekolün, nesne kavramlarını kullanması bu problemi şiddetlendirmekte. Yine de, programlama dilleri topluluğunu bir kenara bıraktığımızda dahi, bir çok farklı terim aynı kavramı, ve bazı durumlarda da, aynı terim farklı kavramları açıklamak için kullanılabilmekte. Ortak terminolojinin olmaması, araştırmacılar, geliştiriciler ve kullanıcılar arasındaki iletişime de engel olmakta.</p>
<p>Bu raporsa, nesne kavramları için ortak bir terminoloji önermekteyiz. Terminoloji, sadece programlama dillerine değil, aynı zamanda farklı alanlara da uygulanabilmeleri için özellikle seçilmiştir. Bu nedenle, nesne-yönelimli programlamadan kaynaklanan birtakım yerleşik terimler de uygunsuz sayılmaktalar. Önemli kavramların açıklanması, anahtar terimleri açıklayan sözlükte yeralmakta.</p>
<p>Bu çalışma, Hewlett-Packard içinde kurumsal iletişimi geliştirmek amacıyla nesne kavramları için ortak terminoloji yaratma çabasından ortaya çıktı. En önce ilgili teknolojileri karşılaştırmak ve karakterize etmek için temel olacak çekirdek kavramları tanımladık ve açıkladık. Kavramlı tanımladıktan hemen sonra, bu kavramlar için terimleri seçtik. Çalışma, Obje Yönetim Grubu (Object Management Group) için soyut bir nesne modeli geliştirilmesi sürecinde rafine edildi ve hali hazırda ANSI tarafından sponsor olunan, nesne modellerini standartlaştırma çabalarında da kullanılmaktadır.</p>
<h4>Önemli Kavramlar</h4>
<ul>
<li>Bir nesne hizmetler tarafından karakterize edilen bir soyutlamanın vücut bulma halidir.</li>
<li>İstemci, nesnelerden hizmetler talep eder. a) İstemciler talep bildirirler. b)Nesneler kapsüllenmişlerdir. c) Talepler işlem belirtirler. d) Talepler nesneleri tanımlayabilirler.</li>
<li>Yeni nesneler yaratılabilirler.</li>
<li>İşlemler jenerik olabilirler.</li>
<li>Nesneler sundukları hizmetlere göre sınıflandırılabilirler (arayüz hiyerarşisi)</li>
<li>Nesneler, uygulanımları (implementation) paylaşabilirler. a) Nesneler ortak bir uygulanımı paylaşabilirler. (bir çok örnek) b) Nesneler kısmı uygulanımları paylaşabilirler. (uygulanım hiyerarşisi veya delegasyon)</li>
</ul>
<h4>2. Başlıca Kavramlar</h4>
<p>Bu bölümde bir nesne sisteminin başlıca kavramları tanımlanmaktadır. Bir nesne sistemi, nesne adı verilen, istemcilere hizmet sunulmasında önemli sol oynayan varlıklara sahiptir. İstemcilerin ve hizmetlerin kesin doğası belirlenmiş nesne sistemine bağlıdır. Genel olarak, bir istemci, bir kişi ya da program olabilir ve bir hizmet istemcinin talebine bağlı olarak gerçekleştirilen herhangi bir aktivite olabilir. Başlıca kavramlar nesne sistemlerinin ortak karakteristiklerini belirlerler. (Wegner ve Thomas tarafından yazılan makaleler, benze materyalleri daha öğretici tarzda sunuyorlar)</p>
<h4>Bir nesne hizmetler tarafından karakterize edilen bir soyutlamanın vücut bulma halidir.</h4>
<p>Bir nesne bir soyutlamanın vücut bulma halidir.</p>
<p>Bir nesne, açıkça istemcileri için anlamlı olan bir soyutlamanın vücut bulmuş halidir. Bir nesne verilerle ilgili olsa da, sadece bir veri yapısı veya 0,1'ler koleksiyonu değildir. Verinin amacı, bilgiyi sunmaktır.</p>
<p>Yarar: İstemciler anlamlı varlıkları manipule ederler. İstemciler veriyi sunmak ya da yorumlamaktan sorumlu değildirler.</p>
<p>Tezat: Nesne içermeyen bir model, verilerin sadece bir bit dizisi olduğu, bit okuyan veya yazan programlar tarafından örtük olarak yorumlanmayla sınırlı olduğu ve farklı programların farklı yorumlamalar yaptığı bir sistemdir. Bu modelde, müşterilerin verilerin nasıl yorumlanacağını bilmeleri gerekir. Ayrıca, veriler yanlış programa verildiğinde, yanlış yorumlanabilir.</p>
<p>Örnek: Dokümanlar, dizinler ve grafikler gibi aşina olunan soyutlamalara denk gelen nesneler, ViewPoint ve HP NewWave ortamının kullanıcılarına sunulmaktadır.</p>
<p>Örnek: Smalltalk programcıları, diziler ve sözlükler gibi aşina oldukları programlama soyutlamalarını destekleyen nesnelere sahiptirler.</p>
<p>Karşıt örnek: Unix içerisinde, sıradan bir dosya, yorumlanmamış bir byte dizisidir. Dosyanın yorumlanması uygulama programlarına bırakılmıştır. Aynı dosya bir C derleyicisi tarafından C kaynak kodu olarak algılanabilir ya da grep (bir metin arama aracı) programı tarafından uzun bir metin dizisi olarak algılanabilir. Farklı dosyaları anlamlı soyutlamalarla ilişkilendirmek için Dosya isimlenddrme kuralları gibi (örneğin foo.c adlı bir dosyanın C kaynak kodu anlamına gelmesi gibi) farklı teknikler kullanılır.</p>
<p>Ayrıntılandırma: Soyutlamalar bir hiyerarşi oluşturarak bir sistemin her düzeyinde ortaya çıkar: daha üst düzey soyutlamalar, daha alt düzey soyutlama terimleriyle uygulanmaktadırlar. Bir dosya, kalıcı bir depolama için bir soyutlamadır ve gerçek depolama cihazlarından daha yüksek seviyededir. Ancak birçok dosya, örtük olarak daha yüksek seviye bir soyutlama uygulamaktadır. Bir C programı eya bir doküman gibi. Çoğu Unix kullanıcısı için anlamlı olan bu üst düzey soyutlamalardır.</p>
<h4>Bir nesne hizmet sağlayıcısıdır</h4>
<p>Nesne tarafından gerçeğe dönüştürülen bir soyutlama, istemciler tarafından talep edilebilen bir hizmetler kümesi tarafından karakterize edilir. Bir hizmet, veriye erişebilir ya da onu değiştirebilir, ve gözlemlenebilir etikleri ortaya çıkarabilir. Hizmet tarafından değiştirilebilen veriye durum (state) denir.</p>
<p>Ayrıntılandırma: Hizmetler somutlaştırılmış soyutlama için uygundur. Hizmetler genellikle karmaşıktırlar; veriler üzerinde keyfi değişikler içerebilir ve diğer nesneleri etkileyecek ek hizmetler talep edebilirler. Sadece adlandırılmış öz niteliklerden oluşan, okunabilen ve yazılabilen bir kayıt, hizmetleri basit okuma ve yazma işlemleri olan ve durum olarak öz niteliklere sahip olan basit bir nesne formudur. Durum (state) belli nesnelerle alakalı veya alakasız olabilir veya farklı nesneler tarafından paylaşılıyor olabilir.</p>
<p>Yarar: Karmaşık sistemler tümleşik kısıtlamaları korumak adına özenle tasarlanmış olabilirler. Eğer sadece ilkel hizmetler sunuluyorsa, istemciler kendiliğinden bu hizmetleri daha karışık hizmetlerde bütünleştirmek zorunda kalabilirler ve bu da muhtemel hatalara sebep olabilir.</p>
<p>Örnek: Bir sözlük nesnesi, istemci için isimden değer döndüren bir hizmet sunar. Bu hizmetin uygulanması, sıralı ikili ağaç gibi karmaşık bir veri yapısının inşa edilmesini ve değiştirilmesini gerektirebilir. Altta yatan veri yapısının hatalı bir şekilde değiştirilmesi, ikili ağacın hatalı sıralanmasına ve sözlük hizmetlerinin hatalı davranmasına sebep olabilir.</p>
<p>Örnek: Dağıtık bir ortamda bir yazdırma kuyruğu nesnesi, birden fazla kullanıcının metin dosyalarının yazdırma kuyruğuna ataması hizmetini sunar. Bu hizmet, herhangi bir müdahele olmadan taleplerin eşzamanlı olarak sunulabildiği bir işlem mekanizması kullanılarak uygulanabilir. Eğer uygulamalar sadece düşük seviye okuma ve yazma işlemleri sunuyorlarsa, müdahele edilmemeyi garanti etmek adına bu düşük seviye hizmetlerin sıralı olarak birleştirilmesi gerekebilir. Bu durumda, yazdırma kuyruğu güvenirliği garanti edemez çünkü eşzamanlı taleplerin doğru işlenmesi, ayrı ayrı uygulamaların doğruluklarına bağımlıdır.</p>
<p>Karşıt örnek: Standart Unix Posta Teslimat hizmeti, kullanıcının posta kutusu dosyasına belirli bir protokolü izleyerek erişen uygulamalara dayalıdır. Bu protokol, bir kilit dosyası yaratmayı ve test etmeyi gerektiren belirli ve sıralı adımlara ihtiyaç duyar. Eğer bir uygulama, yeni bir postayı, posta kutusu doyasından çıkarırken bu protokolü izlemede hata yaparsa, eş zamanlı iletilen mesajlar kaybolabilir veya bozulabilirler.</p>
<h4>İstemciler nesnelerden hizmetler talep ederler.</h4>
<p>İstemciler talep bildirirler.</p>
<p>İstemciler nesnede vücut bulmuş soyutlamaya saygı duyarlar. Veriye direkt olarak erişmek yerine, istemciler nesnelerle ilişkili hizmetlere taleplerini bildirirler. Bir talep, talep edilen hizmeti gerçekleştirecek kodun çalışmasını sağlar. İstemci, kodun nerede ve nasıl çalıştığı ile değil, sadece istediği hizmetin çalışmasıyla ilgilidir. Bir talebin davranışı, istenen ve gerçekleştirilen hizmetin görünür etkisidir. (sonuçları ile beraber)</p>
<p>Yarar: İstemciler bir hizmetin gerçekleşmesi için hangi kodun çalışması gerektiğini hatırlamak zorunda değildirler. İstemciler hatayla yanlış kodu çalıştıramazlar.</p>
<p>Örnek: ViewPoint ve HP NewWave kullanıcıları belirli bir nesneyi değiştirmek için hangi uyuglamanın çalışması gerektiğini hatılamak zorunda değildirler; sistem uygun uygulamayu, kullanıcı taleplerine cevap olarak çağıracaktır. (örneğin, bir ikona yönelen fare harekerleri ile tetiklenmiş olabilirler)</p>
<p>Örnek: Bir Smalltalk programı, bir nesneye mesaj göndererek hizmet talebinde bulunur. Nesne, istenen hizmetin nasıl gerçekleşeceğinden sorumludur. Smalltalk içindeki tek tür hatası, istenen hizmetin mevcut olmamasıdır. Yanlış veriye kod uygulanamaz.</p>
<p>Yarar: İstemcileri, nesnenin uygulanmasından izole ederek, nesnenin uygulanmasını, istemciyi değiştirmeye gerek kalmadan değiştirmek mümkündür.(Hizmetlerin, istemcilere değişmez göründüğü varsayılır)</p>
<p>Örnek: Nesne-yönelimli programlamayı kullanan bir programcı, sözlük nesnelerini uygulamak için, bir çok durumda, dramatik olarak performansı iyileştiren yeni bir teknik keşfeder. Bu teknik, sıralı bir ikili ağaç yerine, hash tablosu kullanmaktadır. Sözlük nesnesinin yeni uygulanımı, veri formatı ve hizmetlerin uygulanımı farklı olsa da, eskisinin aynısı hizmetleri aynı şekilde sunmaktadır. Yeni sözlük uygulanımı, yeni nesne kütüphanesi yayınlandığında eskisinin yerini alır. İstemci kaynak kodunun değişmesine veya yeniden derlenmesine gerek yoktur.</p>
<p>Örnek: Bir HP SoftBench yazılım geliştirme ortamı kullanıcısı, standart SoftBench düzenleyicisi yerine GNU Emacs düzenleyicisi kullanmaya karar verir. GNU Emacs düzenleyicisi, SoftBench düzenleyicisi gibi (diğer uygulamalar için) aynı hizmetleri desteklediği için, düzenleyici hizmetine talep eden diğer uygulamalar, GNU Emacs düzenleyicisini kullanarak çalışmaya devam edeceklerdir.</p>
<p>Örnek: HP SoftBench ortamına, dış bir araç, HP Encapsulator programı, istemci taleplerini karşılayacak olan araç için sarmalayıcı yaratılarak, gömülebilir.</p>
<p>Örnek: Dış bir veritabanına, Iris veritabanına, istemcilerden gelen talepleri, uygun dış veritabanı çağrılarına dönüştüren dış işlevlerin sağlanmasıyla erişilebilir. (Iris içindeki dış işlev, konvansiyonel bir programlama dili kullanılarak yazılmış bir programdır.)</p>
<h4>Nesneler Kapsüllenmişlerdir.</h4>
<p>Bir istemci, nesnelere sadece hizmet talepleri göndererek erişebilir. İstemcilerin, nesnelerle bağlantılı olan verilere erişmeleri ve değiştirmeleri engellenir.</p>
<p>Yarar: Verilerle direk ilişkiye geçilmesini engelleyerek nesnelerin birtakım tümleşik kısıtlamalara uymaları garanti edilmektedir. Ayrıca istemcilerin de nesnelerin uygulanımlarından etkilenmemeleri de garanti edilmektedir.</p>
<p>Örnek: Smalltak ve C++ gibi nesne-yönelimli programlama dillerinde, bir istemcinin, bir nesnenin anlık özel değişkenlerine (private instance variable) doğrudan erişeleri, normal kullanımda engellenmektedir. (Ancak iki dilde de olağandışı durumlarda bu kısıtlamaların etrafından dolaşmayı sağlayan birtakım yapılar mevcuttur)</p>
<h4>Talepler, işlemleri tanımlarlar.</h4>
<p>Bir talep, bir hizmetin gerçekleştirilmesini, bir işlem tanımlayarak işaret eder. Bir işlem, bir hizmet belirten ve tanımlanabilen bir varlıktır.</p>
<p>Örnek: HP NewWave masaüstü, kullanıcının bir takım yollarla, örneğin, -menü öğelerini seçmek ya da ikonları çöp kutusuna ya da yazıcı ikonun sürükleyip bırakmak gibi- işlemleri tanımlamasına izin verir.</p>
<p>Örnek: C++ dilinde, bir işlem, belirli bir sınıfta, belirli üye metoduna, mevcut olan öz niteliklerin tür tanımlamaları yapılarak isim verilmesiyle tanımlanır. (öz niteliklerin tür tanımları, aşırı yüklenmiş metodları çözmek için kullanılır) Eğer iki sınıf aynı metod ismini tanımlıyor ve metod ortak bir ata sınıftan miras alınmış sanal bir metod değilse, o zaman metodlar iki farklı işlem olarak dikkate alınır.</p>
<p>Örnek: Common Lisp Nesne Sisteminde, bir işlem, belirli bir jenerik metod nesnesi ile tanımlanır. Farklı bağlamlardaki aynı metinsel isim, farklı jenerik metod nesnlererine işaret edebilir ve bu durumda da farklı işlemler olarak dikkate alınırlar.</p>
<p>Örnek: Açık sistemlerin yönetimi için taslak ISO standardında, bir işlem, global olarak bir kayıt otoritesi (registration authority) tarafından atanan eşsiz bir belirleyici (unique identifier) ile tanımlanmaktadır.</p>
<h4>Talepler, nesneleri tanımlayabilirler.</h4>
<p>Bir talep, ilişkili öz niteliklere sahip olabilir ve bir hizmet bir veya birden daha fazla sonuç döndürebilir. Bir öz nitelik veya bir sonuç bir nesneyi tanımlıyor olabilir. (Çoğu sistemde her talep için varolan tanımlanmış öz nitelik, talebi gerçekleştirmek için varolan nesneyi tanımlasa da, başka ihtimaller de mevcuttur. -Klasik ve jenerik nesne modelleri tablosuna bakınız.)</p>
<p>Bir nesne doğrudan ve güvenilir olarak tanımlanabilir. Nesne tanımlaması, nesnenin tanımlanması bakımından değil, adlandırılamsı bakımından doğrudandır. Nesne tanımlaması, güvenilirdir çünkü, bir tanımlayıcının tekrar edilmesi, her zaman aynı nesneyi işaret edecektir. (Uzay zamanın pragmatik sınırlarına özne olarak) Nesneyi tanımlayan bir değer, nesne referansı olarak adlandırılır.</p>
<p>Ayrıntılandırma: İlişkili bir duruma sahip olan bir nesnenin, durum değişkenlerinin o anki değerlerini aşkın bir kimliği vardır; iki nesne aynı anlık duruma sahip olabilir, biri durumunu değiştirebilir ve diğeri değişmeden kalabilir. Bu gibi nesnelerde, nesne kimliği bir gerekliliktir; nesnenin (öz nitelik terimleri kullanılarak) tanımlanması elverişsiz olacaktır. Bir nesnenin açıklamasını kullanmak, belirgin bir nesne kimliği öz niteliğinin takdim edilmesini gerektirir, ki bu durum, ek değişmez ve eşsiz tümleşik kısıtlamalar getireceğinden avantajsızdır.</p>
<p>Yarar: İstemciler, nesnelere işaret edebilme yeteneklerine bağlı olabilirler. İstemciler, işaret ettikleri nesnenin, (nesne varolduğu sürece) doğru nesneye işaret edip etmemesi veya tamamen başarısız olması konusunda endişelenmek zorunda değildirler.</p>
<p>Örnek: İkonlara sahip olan bir kullanıcı arayüzü, kullanıcıların nesneleri ekran üzerindeki görsel temsiller kullanarak işaret etmelerini sağlar. Bu kullanıcı arayüzü görsel temsil kullanarak altta yatan veriye ulaşılmasını sağlar. İkonlardan veriye ulaşılması bir harita kadar güvenilir olduğu için, kullanıcılar o ikonların doğrudan veri olduklarını düşüneceklerdir.</p>
<p><strong>Klasik ve Genelleştirilmiş Nesne Modelleri</strong></p>
<p>En güncel nesne sistemleri, klasik nesne modeline sahiptirler. Klasik nesne modelinde, her talep hedef nesneyi tanımlayan açık bir öz niteliğe sahiptir. Hedef nesne, talebin yorumlanmasını kontrol etmektedir. Klasik nesne modelinde bir talep mesaj olarak adlandırılır ve işlendiği hedef nesnesine ulaştığı anda görülmeye başlanır. Örneğin, bir yazıcıda bir doküman yazdırmak için varolan bir talep, yazıcı nesnesine gönderilen belge yazdırma talebi olabilir.</p>
<p>Genelleştirilmiş nesne modeli ise, talebin hedef nesneyi açıkça belirtmesini gerektirmez. Bir istek, sıfır veya daha fazla öz niteliğe sahip olabilir, bunlardan herhangi biri nir nesneyi işaret edebilir. Bir talebin yorumlanması, bu öz niteliklerin biri veya hepsine bağlı olabilir; özellikle belirtilen bir öz nitelik yoktur. Hizmet bu işaret edilen nesnelerden biri veya 3. parti tarafından sunuluyor olabilir. Örneğin, belirli bir yazıcıda, belirli bir dokümanı yazdırma talebi, özel bir çeşit belgeyi, yine özel bir çeşit yazıcıda yazdırmak için oluşturulmuş bir işlem tarafından halledilebilir. Bu işlem, sadece bu özel çeşit belgeyi yine özel çeşit yazıcıda çalıştırma talebi geldiğinde çalıştırılacaktır.</p>
<p>Genelleştirilmiş nesne modeli, klasik nesne modelini, özel bir durum olarak içermektedir. Bir mesajın klasik olarak bir nesneye gönderilmesi, hizmetin bir nesne tarafından belirli bir öz nitelikle ve klasik modelde ayrık bir öz nitelik kullanılarak sunulduğu, genelleştirilmiş talebin eşitidir. Genelleştirilmiş nesne modeli, bir talebin yorumlanmasının, kesin olarak, belirlenmiş bir işleme dayalı olduğu sıradan işlemleri özel bir durum olarak da içerir.</p>
<p>Genelleştirilmiş nesne modelleri, Common Lisp Nesne Sistemi ve Irıs veritabanlarında kullanılmaktadır. Genelleştirilmiş Modellerin nerelerde ortaya çıktıkları henüz tamamen bilinmese de, uygulama bilgisinin özenle parçalanamadığı ayrık nesneler arasında, daha genel bir nesne modelinin gerekliliği açıktır.</p>
<p>Karşıt Örnek: Standart Unix kullanıcı arayüzü, dosyalara işaret etmek için metinsel isimler kullanır. Metinsel isim, dizin hiyerarşisi kullanılarak asıl dosyaya işaret eder. Bu işaretleme, her an dosyalar taşınabildiği ve dizin yapısı yeniden düzenlenebildiği için güvenilir değildir. Örneğin, bir kullanıcı, dizini listelediğinde, bir foo dosyası görüntüleniyorsa, kullanıcı bir sonraki listelemede foo isminin yine aynı dosyayı mı, yoksa farklı bir dosyayı mı işaret ettiğinden emin olamaz. (Unix çekirdeği içinde, inode sayıları, güvenilir bir şekilde dosyaları tanımlamak için kullanılmaktadır.)</p>
<p>Örnek: Unix’in bir dosya isminin güvenilir olarak bir dosyayı işaret edemedii dizin listelemesinin aksine, Dynamic Windows’da, sistem hangi dosyanın (nesnenin) ekrandaki hangi metine işaret ettiğini hatırlar. Eğer listeleme bir foo dosyası gösteriyor ise, kullanıcı ekrandaki foo metnine tıkladığı anda, dosya ile yapabileceği işlemleri gösteren bir menu ortaya çıkar. Dosya yeniden adlandırılsa bile bu işlem çalışmaktadır.</p>
<p>Örnek: HP NewWave ortamında, bir uygulama belge nesnesinden, grafik nesnesine bir bağlantı oluşturabilir. Bu bağlantı, kullanıcı grafik nesnesini başka bir dizine taşısa dahi varolmaya devam edecektir. Belge başka bir sisteme kopyalandığında, grafik nesnesi de aynı zamanda kopyalanacaktır.</p>
<p>Karşıt Örnek: Unix içinde, bir C kaynak kodu dosyası, başka dosyalara isimleriyle atıfta bulunabilir. Eğer dizin yapısı yeniden düzenlenirse, dosya içinde atıfta bulunulan “bağlantı” da bozulabilir. Dosya ismi yanlış bir dosyaya işaret edebilir ya da işaret ettiği yerde dosya mevcut olmayabilir.</p>
<p>Örnek: C++’da nesneler, işaretçiler ve referanslar kullanılarak tanımlanmaktadır. Bir işaretçi veya referans, işaret ettiği nesne varoldu sürece geçerlidir.</p>
<p>Karşıt örnek: İlişkisel bir veritabanında, bir değişkenler demetine (tuple) (bir sorgu içinde) demetin öz niteliklerini tanımlayan değer tanımları vasıtasıyla erişilebilir. Farklı demetler (Tuple), eğer öznitelikler değiştiriliyorsa, aynı tanım ile farklı zamanlarda erişiliyor olabilir. (Bir demete (tuple) güvenilir erişim, sadece demet (tuple) içerisinde anahtar öz nitelikler varsa yapılabilir. Anahtar öz nitelikler, birbiriyle ilişkisi olan değişken demetlerini (tuple) eşsiz biçimde tanımlayan değişmez öz niteliklerdir.</p>
<p>Karşıt örnek: HP SoftBench Ortamında, talep mesajının hedefi, bir araç sınıfından, bir mesaj isminden ve özel bir veri dosyasını tanımlayan bir metinden oluşan açıklama vasıtasıyla tanımlanmaktadır. Bir araç aktivasyonu, bu değerleri, her araç tarafından belirtilen karşılık gelen değerlerle eşleştirerek istenen hizmeti gerçekleştirmek için seçilir. İstemci, aynı aracın ya da araç aktivasyonunun, her seferinde istemci mesajı tarafından verilen belirli tanımlama cevabını vereceğini varsayamaz. Gerçekte, istemci, herhangi bir araç aktivasyonunun cevap vereceğini veya en fazla bir araç aktivasyonunun cevap vereceğini varsayamaz.</p>
<p>Yarar: Doğrudan nesnenin tanımlanması, normalde, nesneyi, kendi açıklamasına bağlı olarak tanımlamaktan daha verimlidir.</p>
<h4>Yeni nesneler yaratılabilirler.</h4>
<p>İstemci varolan nesnelerden farklı olan yeni nesnelerin yaratılmasını talep edebilir.</p>
<p>Yarar: Zamana bağlı değişen davranışa sahip olan nesneler, birden çok istemcilerin etkileşimine izin verirler. Yeni nesnelerin yaratılması, istemcilerin yanlışlıkla aynı nesneyi paylaşarak çatışmalarını önlemek için kullanılır. İstemciler, yeni yaratılan nesnelerin ayrıklığından sorumlu değildirler.</p>
<p>Örnek: Bir istemci programı yeni ve boş bir sözlük nesnesi yaratır. Yeni sözlük nesnesi, tüm diğer sözlük nesnelerinden, hatta boş olanlardan dahi ayrıktır. Eğer istemci, bu sözlük nesnesinin durumunu, bir isim ve bağlantılı değer girerek değiştirirse, diğer sözlük nesneleri etkilenmeyeceklerdir.</p>
<p>Örnek: Bir ViewPoint kullanıcısı, yeni bir belge yaratır. Örneğin, varolan bir belgeyi kopyalar. Yeni belge, ekranda yeni bir ikon olarak, diğer tüm belgelerden görünür olarak ayrıktır. Belgenin eşsizliği sistem tarafından garanti edilmektedir. Kullanıcı, belgeye herhangi bir eşsiz isim atamak zorunda değildir.</p>
<h4>İşlemler jenerik olabilirler.</h4>
<p>Bir hizmetin, farklı nesneler için, gözle görünür biçimde farklı davranışları olan, (benzer amaçları paylaşıyor olsalar dahi) farklı uygulanımları (farklı kodu) olabilir. Bir istemci her nesne veya hizmet için aynı talepleri bildiriyor olabilir. (Talepler ortak bir işlemi tanımlarlar) ve her ayrı talep için, uygun bir uygulanım seçilir. Verilen bir hizmet için farklı uygulanımların olmasında bir sayı sınırı yoktur.</p>
<p>Birden çok uygulanımı bulunan işleme, jenerik işlem adı verilir. Jenerik işlemleri talep eden istemcilerin kendileri de, farklı nesne çeşitleri üzerinde ortak bir aktivite gerçekleştirebilmeleri bakımından jenerik olabilirler.</p>
<p>Bir hizmeti gerçekleştirmek için kod seçimi (bağlama) (binding), talep içinde tanımlanmış nesnelere dayalıdır. Genel olarak, nesnelerin tanımlanması, istek bildirildiği and meydana gelmektedir, bu sayede kod seçimi, tam o anda meydana gelebilir. (dinamik bağlama) (dynamic binding) Bazı zamanlarda, kod seçimi, yürütme zamanından önce bilinen etkenlere bağlıdır, o zaman kod, programın derlenme ya da linking anında seçilebilir. (static binding) (static binding)</p>
<p>Yarar: Jenerik işlemlerin bir yararı, sistemin şeffaf bir şekilde bir hizmetin çoklu uygulanımlarını sunmasıdır. Bu özel durumda, uygulanımlar, gözlemlenebilir şekilde eşit etkiler üretirler. Bir hizmeti talep eden istemcinin, farklı nesneler için farklı kodların çalıştığını bilmesine gerek yoktur.</p>
<p>Örnek: Bir heterojen dağıtık sistem, farklı donanım mimarilerinde uygulamanın farklı versiyonlarını sunuyor olabilir. İstemci uygulaması, basitçe, hedef nesnenin yere bağlı olarak hangi kodu çalıştıracağını bilmeden taleplerde bulunur.</p>
<p>Örnek: Modemleri yönetmeye yarayan bir ağ yönetim uygulaması, sistemdeki modemlerin yerine bağlı olarak farklı kodların yürütülebileceğini bilmeden, basitçe modemlere isteklerde bulunur.</p>
<p>Örnek: Sözlük nesnelerinin yeni bir uygulanımı, farklı bir isim altında kütüphaneye eklenmiştir, bu sayede eski uygulanım sistemde varolmaya devam etmektedir. Yeni uygulanım, bir çok durumda daha yüksek performans sunmaktadır, ancak bazı kullanım desenlerine bağlı olarak eski uygulanımın bazı koşullarda daha iyi performansa sahip olduğu bilinmektedir. Sözlük nesnelerini kullanan bir istemci program, beklenen kullanıma bağlı olarak, yarattığı her sözlük için daha uygun uygulanımı seçmek üzere değiştirilmiştir. Sözlük nesnelerini kullanan program parçaları değiştirilmemiştir, iki uygulanımla birlikte çalışırlar.</p>
<p>Yarar: Jenerik işlemlerin bir diğer yararı da kodun daha genel olmasıdır, bu sayede kodun yeniden kullanılabilirliği artar. Bu durumda, jenerik işlemin, farklı uygulanımları gözle görülür biçimde farklı etkiler üretebilirler.</p>
<p>Örnek: Karşılaştırma hizmeti sunan bir nesneler kümesini sıralayacak bir sıralama modülü sunulabilir.</p>
<p>Yarar: Kullanıcı ara yüzleri örneğinde, kullanıcılar, bir çok durumda standart bir zihinsel model kullanabilirler.</p>
<p>Örnek: ViewPoint, atanmış işlev tuşları kullanarak, herhangi bir tür nesne üzerinde çalıştırılabilecek jenerik komut kümeleri sunmaktadır.</p>
<p>Örnek: HP NewWave ortamının kullanıcılarının, herhangi bir tür nesneyi yazdırmak için, sadece nesneyi yazıcı ikonunun üzerine sürükleyip bırakmayı hatırlamaları yeterlidir.</p>
<p>Yarar: Jenerik işlemler, açık sistemlerin gerçekleştirimlerini kolaylaştırmaktadır. Açık bir sistem, yeni nesnelerin dinamik olarak ortaya konduğu ve bu sayede yeni nesnelerin, varolan istemcilerin kodları değiştirilmeden çalıştırıldığı sistemlerdir. Varolan istemciler, istemci taleplerini destekledikleri için yeni yaratılmış nesneleri kullanabilirler. Açık bir sistem yeni yazılım bileşenlerinin yaratılmasına ve sistem çalışırken yüklenmesine olanak verir. Açık sistemlerin evrilmeleri ve geliştirilmeleri daha kolaydır.</p>
<h4>Nesneler sundukları hizmetlere göre sınıflandırılabilirler.</h4>
<p>Nesneler bağlı olan hizmetler, arayüz şeklinde açıklanabilirler. Bir arayüz, nesnenin istemci tarafından nasıl kullanıldığını, nesneyi öz nitelik olarak tanımlayan muhtemel istekler kümesini tanımlayarak açıklar. Bu tanımlama, diğer istek özniteliklerinin mantıklı değerlerini ve her taleple ilgili muhtemel sonuçları içerebilir ve ayrıca taleplerin davranışlarını da açıklayabilir. Nesneler sundukları hizmetlere göre, yani sundukları arayüzlerin terimleriyle sınıflandırılabilirler.</p>
<p>Yarar: Nesnelerin hizmetlerine dayalı sınıflandırması, nesnelerin anlaşılmasını kolaylaştırmak için nesneleri organize etmenin bir yoludur. Nesnenin bir sınıflandırması, nesneden istemci tarafından beklenen hizmetleri açıklamak ve derleme zamanında nesnelerin hatalı kullanımlarını kontrol etmek için de kullanılabilir. (örneğin nesnenin desteklemediği bir işlemin gerçekleştirilmesinin talep edilmesi gibi tür hataları)</p>
<p>Örnek: HP NewWave ortamının bir kullanıcısı, menülerden istifade ederek bir nesneyle ilgili geçerli işlemleri görsel olarak belirleyebilir. Seçili nesne için geçerli olmayan işlemler, uygulanabilir işlemlerden ayırt etmek için gölgeli olarak gösterilir.</p>
<p>Karşıt örnek: Bir Unix kullanıcısı, ayrı ayrı her dosya için hangi komutların uygulanabileceğini hatırlamak zorundadır. Eğer kullanıcı bir hata yapar ve yanlış dosya türü için yanlış komutu çalıştırırsa, bekleyeceği en iyi şey komutun dosyanın hatalı türde olduğunu tespit ederek bir hata mesajı vermesidir. Kullanıcının verilen bir dosya için uygun komutları bilebilmesinin doğrudan bir yolu yoktur.</p>
<p>Örnek: Bir C++ sınıfı, nesnenin örnekleri (instance) tarafından sunulan hizemetleri, her örnekteki üye metodları listeleyerek tanımlar. Ayrıca statik tür kontrolü amacı için, bir tür olarak hizmet eder. (Bir C++ sınıfı, sınıfın örneğinin sunduğu hizmetleri açıklamaktan daha çok iş yapar, ayrıca sınıfın uygulanımlarını da tanımlar.)</p>
<p>Örnek: Açık sistemlerin yönetimi için taslak ISO Standartlarında, bir sistem yönetim nesnesi, bir nesnenin öz nitelik ve eylemleri belirtilerek tanımlanır. Geliştiriciler, sınıfı nesneye erişen uygulamalar yazmak için kullanırlar.</p>
<p>Bir nesne, farklı bir nesnenin sunduğu hizmetlerin bir altkümesini sunabilir, bu da hiyerarşik sınıflandırmaya yol açar. (Hiyerarşi terimi, birçok nesne sistemi daha genel sınıflandırma yapılarını desteklemelerine rağmen sıklıkla gayri resmi bir şekilde kullanılmaktadır.) Arayüz hiyerarşisi aynı zamanda tür hiyerarşisi olarak da kullanılabilir, örneğin, istek öz niteliklerinin mantıklı değerlerini tanımlamak için.</p>
<blockquote><strong>Bağlantılı kavramlar.</strong></blockquote>
<blockquote>Nesne sistemleri incelememizde, belirli kavramlar, zorunlu olmayan bir şekilde nesne fikrine bağlı olarak yeterli sıklıkla karşımıza çıkarlar. Belki de gelecekte düşüncelerimiz evrimleştikçe, bu çağrışımlar daha da güçlenecek ve nesnelerin özünün bir parçası olarak kabul edilecekler.</blockquote>
<blockquote>
<strong>Olay bildirimi (Event notification). </strong>Bir istemci, durum değişikliği gibi, bir nesneyle bağlantılı bir olay ve koşula olan ilgisini kayıt altına alabilir ve olay veya koşul meydana geldiğinde bildirim alabilir.</blockquote>
<blockquote>
<strong>Olaya dayalı kontrol yapısı (Event-driven control structure). </strong>Bir program yapısı, gelen olayları bekleyen ve onları uygun işleyicilere sev eden üst seviye olay örgüsü ile karakterize edilir.</blockquote>
<blockquote>
<strong>Sunum-semantik bölünmesi (Presentation-semantic split). </strong>Bir program yapısı, soyut bir bilgiyi (semantik bir nesne) modelleyen ve bu tarz bilgiyi kullanıcıya sunan (bir sunum nesnesi) farklı nesnelerin kullanılmasıyla karakterize edilir. Tekil bir semantik nesne, birden fazla, bağlantılı, farklı sunum nesnelerine sahip olabilir. Örneğin, finansal verilerin, pasta diyagramı ve çubuk diyagramı ile aynı anda gösterilebilmesi gibi.</blockquote>
<blockquote>
<strong>Bileşik nesneler (Composite objects). </strong>Bir bileşik nesne, birden fazla farklı nesnenin birbirleriyle birleştirilmesi (combining) veya bağlanması (linking) ile oluşur. Bu sayede bileşik nesne üzerinde tek bir nesne gibi değişiklik yapılabilir. (kopyalanabilir ya da taşınabilir.) Örneğin, bir belge nesnesi, belge içindeki bir figürde bulunan bir grafik nesnesi ile bağlantılı olabilir. Bir sıcak bağlantı (hot link) grafiğe bağlı olan veri değiştiği anda, belgenin güncellenmesini sağlar.</blockquote>
<blockquote>
<strong>Aktif nesneler (Active objects).</strong> Aktif bir nesne, bir istemci tarafından talep edilmeden, hesaplamayı (computation) kendiliğinden başlatabilir. Aktif bir nesne, eşzamanlı bir işlemdir; kendine ait bir etkinliğe ve kontrol için iş parçacığına sahiptir. (thread of control)</blockquote>
<blockquote>
<strong>İlişkiler (Relationships). </strong>Bir ilişki birden fazla nesneyle, ayrı ayrı olmadan alakalı olan bilgidir. Örneğin, bir çalışan ilişlisi, kurumlar ve kişiler arasındaki ilişkiyi tanımlamaktadır.</blockquote>
<p>Yarar: Bir arayüz hiyerarşisi bir istemcinin, birden fala çeşit nesne üzerinde çalışabileceğini, jenerik işlemler için talep bildiriminde bulunarak gösterir.</p>
<p>Örnek: C++ sınıf türetme üzerine kurulu bir tür hiyerarşisi tanımlar: bir C++ sınıfının örneği, (referans veya işaretçi vasıtasıyla), bir temel (public) sınıf beklendiğinde, herhangi bağlamda kullanılabilir. C++’da sınıf türetme, bir sınıfın örneği, temel sınıf tarafından tanımlanmış tüm hizmetleri sunulduğu anda garanti edilmiş (semantik olarak değil, sentetik olarak) olur.</p>
<p>Örnek: Dynamic Windows kullanıcı arayüzü, sunum türleri için kullanıcıya verilen bağlam için kabul edilebilir nesne kümelerini karakterize eden bir hiyerarşi tanımlamaktadır. Örneğin, bir işleneçten (operand) bir komuta. (command)</p>
<p>Örnek: HP NewWave ortamı, araçlar ve kullanıcı nesneleri ayrımı gibi, ortak hizmetlere bağlı olarak, kavramsal bir hiyerarşi tanımlamaktadır. Kullanıcıların bu ayrımları anlamaları, daha basit bir zihinsel model sağladığı için, kendilerine yarar sağlar.</p>
<h4>Nesneler uygulanımları paylaşabilirler.</h4>
<p>Nesneler ortak bir uygulanımı paylaşabilirler.</p>
<p>Bir nesneyle bağlantılı olan hizmetlerin uygulanımı, genel olarak amaca uygun bilgiyi sunmak için varolan verinin biçimini ve hizmetleri gerçekleştiren kodları hep birlikte tanımlamaktadır. Sunulan mekanizmalar, genelde, birden fazla nesnenin, ortak bir uygulanımı (implementation) paylaşmasına olanak sağlar. Ortak bir uygulanımı paylaşan nesneler, özdeş veri biçimlerini sahiptirler ve yürütlecek kodu da ortak kullanırlar, ancak, her nesne tipik olarak, kendi veri kopyasına sahiptir. Herbir nesne, ortak uygulanımın bir örneği (instance) olarak düşünülebilir.</p>
<p>Yarar: Ortak bir uygulanımı, birçok nesne boyunca paylaşmanın, apaçık şekilde, kaynak kodunun kopyalanmasını azaltması bakımından (ayrıca bu durum değişikliklerin elle yayılmasını engellemesi bakımından kodun bakımını da kolaylaştırır) ve yürütülebilir kod büyüklüğünü azaldır (yürütülenilen kod (executable code) ortak kullanılabildiği sürece) yararı vardır. Bir uygulanımdan birden fazla örnek oluşturabilmenin mümkün olması uygulanımı da daha kullanışlı yapar.</p>
<p>Örnek: Smalltalk ve C++ dillerinde, nesne, sınıfın örneğidir; bir sınıf, her örnek için veri biçimini ve aynı zamanda her örnek tarafından sunulan hizmetleri uygulayan (implementing) işlemleri (procedure) belirlemektedir.</p>
<p>Karşıt örnek: C’de tek bir veri soyutlamasının, gizli (private) değişmez (static) veriler ile çalışan dış metod kümesini tanımlayan bir kaynak kodu dosyası ile uygulanımı gerçekleştirilebilir. Ancak, bu tanımlama, aynı davranışa sahip birden faza varlığın desteklenmesi için örneklenemez.</p>
<h4>Nesneler kısmı uygulanımları paylaşabilirler</h4>
<p>Benzer davranışa sahip nesnelerin, ortak uygulanımlarının belli kısımlarını paylaşmasını sağlayan mekanizmalar sıklıkla sağlanmaktadır.Örneğin, uygulanımın mirası (implementation inheritance), diğer nesne uygulanımlarını genişleterek veya rafine ederek bir nesne uygulanımının artımlı inşasını destekler.</p>
<blockquote>Örnekler</blockquote>
<blockquote>Aşağıdaki örnekler istekleri göstermektedir. Bir istek, (etkisinin açıklaması ile birlikte) öz nitelikler tarafından takip edilen bir işlem olarak gösterilir. S ismi, bir yığın nesnesini tanımlamaktadır. Yığın-fabrikası ismi, yeni yığın nesneleri oluşturan bir nesneyi tanımlar. (Push: İtki)</blockquote>
<blockquote>(yeni yığın-fabrikası) Burada s olarak tanımlanan yeni, boş bir yığını döndürür.</blockquote>
<blockquote>(Push s 3) s’yi değiştirir (3 ile genişletir).</blockquote>
<blockquote>(Push s 4) s’yi değiştirir (4 ile genişletir).</blockquote>
<blockquote>(Pop s) s’yi değiştirir (4'ü kaldırır). 4 döndürür.</blockquote>
<blockquote>(Pop s) s değiştirir (3'ü kaldırır). 3 döndürür.</blockquote>
<blockquote>(Pop s) Boş döndürür, istisna durumudur.</blockquote>
<blockquote>Aşağıdaki örnekler, arayüzleri göstermektedir. Asapların Bir arayüz, bir nesneye uygulanabilen bir dizi isteği tanımlar. Her arabirim, bir istek şeması kümesi olarak gösterilir; burada bir istek şeması, belirli bir işlemi belirten muhtemel taleplerin listesini tanımlayan bir kalıptır. Bir istek şemasında bulunan • sembolü, bir bir arayüzü karşılayan nesnenin, meşru bir şekilde ortaya çıkabileceği bir öz nitelik konumunu ifade eder. Yığın arayüzünde, bir yığın nesnesinin ortaya çıkabileceği bir öz nitelik belirmektedir. Diğer öz nitelikler, türler kullanılarak açıklanmıştır. (Bu durumda, tamsayı)</blockquote>
<blockquote>Yığın arayüzü, bir yığın nesnesini karakterize eden hizmetleri açıklar:</blockquote>
<blockquote>(Push • Tamsayı) Sonuç yok.<br>(Pop • ) Bir tam sayı veya boş değer döndürür, bir istisnadır.</blockquote>
<blockquote>Kuyruk arayüzü, bir kuyruk nesnesini karakterize eden hizmetleri açıklar:</blockquote>
<blockquote>(Push • Tamsayı) Sonuç yok.<br>(Pull • ) Bir tam sayı veya boş değer döndürür, bir istisnadır.</blockquote>
<blockquote>Havuz (Sink) arayüzü, yığınlar ve kuyruklar için ortak olan hizmetleri açıklar:</blockquote>
<blockquote>(Push • Tamsayı) Sonuç yok. (ortak metod, işlev, fonksiyon)</blockquote>
<blockquote>Aşağıdaki şekil, bu üç arabirim arasındaki uygunluk ilişkilerine dayanan bir arabirim hiyerarşisini göstermektedir:</blockquote>
<figure>

<img src="https://cdn-images-1.medium.com/max/800/0*jrRQdOQxT9vLcqYq.">
</figure><p>Yürütme esnasında çalışan benzer bir mekanizmaya Delegasyon adı verilir: Bir nesne, bir isteği diğer nesnelere delege edebilir, ve bu isteğin ardından, asıl talep edilen hizmeti kendisi adına (uygun kısımlarını) yerine getirir. (Delege edilmiş bir talep özel bir taleptir çünkü asıl talep hakkında, sonraki hizmet sağlayıcısının, asıl talebin öz niteliklerini kullanarak başka talepler oluşturmasını sağlayacak şekilde, bilgi taşımaktadır.)</p>
<p>Yarar: Yukarıda listelenen bakım ve boyut avantajlarına ek olarak, uygulanımların kısmı paylaşımı, yazılım yeniden kullanımının faydalarını, gereksinimlerin benzer fakat aynı olmayan durumlara kadar genişletir. Kısmi uygulanımların ortak kullanımı, ilgili nesneler arasında tutarlı davranışı teşvik etmek için yararlı bir tekniktir.</p>
<p>Örnek: Smalltalk ve C++’da, bir sınıf, varolan bir sınıftan (üst sınıf veya temel sınıftan) miras alınarak (türetilerek) tanımlanabilir. Yeni sınıf varolan sınıfın tanımını veri bildirimleri ekleyerek (örnek değişlenleri veya veri üyeleri) ve yeni işlemler uygulayan işlemler (metodlar ya da üye fonksiyonlar) tanımlayarak genişletebilir. Yeni sınıf, varolan sınıfın tanımını ayrı ayrı metodları veya üye fonksiyonları değiştirerek ya da iyileştirerek varolan sınıfın tanımını rafine hale getirebilir. Bir sınıf, miras alma kullanılarak değişimi destekleyecek şekilde tasarlanabilir: Sınıf, belli başlı metodları miras alarak, değiştirerek veya iyileştirerek özelleştirilebilir. Örneğin grafik nesneleri için ortak davranışı tanımlayan genel grafik nesnesi sınıfı, “resim çiz” (draw) metodunun belirli bir grafik nesnesi tanımlayan her miras alan sınıfta değiştirilmesi beklentisiyle tasarlanabilir.</p>
<h4>3 Terminoloji</h4>
<p>Bu bölümde, yukarıda tanıtılan temel kavramlar ve bizim tecrübemize göre iletişim sorunlarına neden olabilecek ek konular için terimler tanımlamaktayız. Terimleri belirli alanlardaki, (nesne-yönelimli programlama gibi), ya da belirli sistemlerdeki (C++ programlama dili gibi) ortak kullanımlarına göre birbirleriyle ilişkilendirmekteyiz. Terimler eşanlamlılarının seçimi ve mevcut kullanımdaki ilişkili terimleri ile birlikte ekteki tabloda gösterilmişlerdir. Tanımlar üç bölüme ayrılmıştır: soyutlama ile ilgili terimler, talep eden hizmetlerle ilgili terimler ve hizmet sunumuyla ilgili terimler.</p>
<h4>3.1 Soyutlama ile ilgili terimler</h4>
<h4>Nesne</h4>
<p>Tanım: Bir nesne, istemciler (kişiler veya programlar) tarafından talep edilen hizmetleri sunmakta görünür rol oynayan varlıktır. Bir nesne açıkça belirli taleplerin davranışı ile karakterize edilen soyutlamanın vücut bulmuş halidir. Hizmetler, nesnelerle ilişkili verilere erişebilir veya bunları değiştirebilir. Hizmetler, verilerin biçimine veya hizmetleri uygulanımı için kullanılan algoritmalara bağımlı olmadan tanımlanmaktadır; Özellikle, aynı davranışın birkaç muhtemel uygulanımı olabilir. Tanımlanan bir hizmete, işlem (operation) adı verilir.</p>
<blockquote><strong>Önerilen Terimler ve mevcut kullanımla ilgili olan terimler</strong></blockquote>
<blockquote>
<strong>Nesne:</strong> Örnek, sınıf örneği, vekil, varlık</blockquote>
<blockquote>
<strong>Kapsüllenmiş nesne:</strong> Bilgi gizleme</blockquote>
<blockquote>
<strong>Gömülü nesne:</strong> Kapsüllenmiş araç, vekil (proxy), dış metod, entegre uygulama</blockquote>
<blockquote>
<strong>Korumalı nesne:</strong> Erişim kontrolü</blockquote>
<blockquote>
<strong>Nesne referansı: olanak, </strong>tanıtıcısı, nesne referansı, nesne adı</blockquote>
<blockquote>
<strong>Talep (istek):</strong> mesaj, metod çağırma, fonksiyon çağırma</blockquote>
<blockquote>
<strong>Genel (jenerik) işlem:</strong> mesaj seçici, metod, genel (jenerik) fonksiyon, aşırı yüklü fonksiyon, sanal üye fonksiyonu, polimorfizm, dinamik bağlama <strong>Arayüz:</strong> Protokol, tür, soyut sınıf, sanal sınıf, imza</blockquote>
<blockquote>
<strong>Arayüz hiyerarşisi:</strong> Kalıtım (Miras alma), özellik hiyerarşisi, tür hiyerarşisi, sınıf hiyerarşisi, alt-türleme, uyumluluk</blockquote>
<blockquote>
<strong>Tür:</strong> sınıf</blockquote>
<blockquote>
<strong>Alt sınıf:</strong> alt sınıf, türetilmiş sınıf</blockquote>
<blockquote>
<strong>Dinamik bağlama:</strong> geç bağlama</blockquote>
<blockquote>
<strong>Statik bağlama:</strong> erken bağlama</blockquote>
<blockquote>
<strong>Nesne uygulanımı:</strong> sınıf, tür, şablon, yönetici, sunucu</blockquote>
<blockquote>
<strong>Durum değişkeni:</strong> Örnek değişkeni, veri üyesi, öz nitelik, alan, oluk (slot)</blockquote>
<blockquote>
<strong>Yöntem:</strong> Üye foksiyon</blockquote>
<blockquote>
<strong>Uygulanım mirası:</strong> alt-sınıflama (sub-classing), türev, ön ek alma</blockquote>
<p>Örnek: Nesnenin basit bir örneği push ve pop işlemleriyle davranışı karakterize edilen, yığın (stack) veri yapısıdır. Bu işlemler, altta yatan veri gösterimine (ki dizi veya bağlantılı liste olabilir) referans verilmeden, doğrudan tanımlanmakta ve kullanılmaktadırlar. Push ve pop işlemleri için gereken kod parçaları, soyut yığın yapısının parçası olmayan, array-index veya list-head gibi gizli (private) işlemler aracılığıyla altta yatan veriye erişirler.</p>
<p>Eş Anlamlılar ve İlgili Terimler: Nesnelere bazen <em>sınıf örnekleri</em> adı verilir. Bazı zamanlarda nesnenin, başka birşeyi modellediğini ifade etmek için suret (vekil, surrogate) terimi de kullanılmaktadır.</p>
<h4>Kapsüllenmiş nesne</h4>
<p>Tanım: Sadece istemciler tarafından talep bildirildiğinde erişilebilen nesne türüne kapsüllenmiş nesne adı verilir.</p>
<p>Örnek: C++ gibi, nesne yönelimli bir programlama dilinde, nesnenin uygulanımı için kullanılan veri yapıları ve ilgili işlemler, nesneye istekte bulunan istemcilerden gizlenmişlerdir. Örneğin, bağlantılı liste kullanılarak yazılmış bir yığına, istemciler bağlantılı liste işlemleri kullanarak erişemezler.</p>
<p>Eş anlamlılar ve İlgili Terimler: Kapsülleme, aynı zamanda <em>bilgi gizleme</em> olarak da adlandırılmaktadır. Kapsülleme terimi bazen, nesnenin bağımsız, yani diğer nesnelerle bilgi paylaşmadığını ve fiziksel olarak tek bir yerde temsil ettiğini vurgulamak için kullanılır.</p>
<p>Gerekçe: Bu kavram, kapsülleme teriminin üç ortak anlamından biridir. Bu tanımın amacı, tercih edilen kullanımı belirtmektir. Sonraki iki tanım, diğer anlamlar için alternatif terimler sunar.</p>
<h4>Gömülü nesne</h4>
<p>Tanım: Gömülü nesne, hali hazırda var olan bir yapı veya işlemin (örneğin nesne olmayan) nesne yapısına sarıldığı, uygun bir arayüz kodu ile yaratılan nesnedir.</p>
<p>Örnek: Uç birim (terminal) için yazılmış bir uygulama, kullanıcı arayüzü tarafından üretilen istekleri, kullanıcı tarafından girilen karakterleri, çıktı karakterleri olarak uygun sunum nesnelerine çevirerek nesne-yönelimli kullanıcı arayüzü standartlarına uyması için üretilmiştir.</p>
<p>Eş Anlamlılar ve İlgili Terimler: Gömülü nesneler oluşturmaya, genellikle kapsülleme veya araç kapsülleme adı verilmektedir. Kapsülleme teriminin bu kullanımı, kapsüllenmiş nesne ifadesinden farklıdır. Uygulama entegrasyonu ve Araç entegrasyonu terimleri ilgili terimlere dahillerdir. Ağ yönetiminde kullanılan gömülü nesnelere vekil (proxy) adı verilir.</p>
<p>Gerekçe: Bu kavram, kapsülleme teriminin yaygın olarak kullanıldığı üç kavramdan biridir. Gömme terimi, bu kavramı, kapsüllenmiş nesnelerden ayırt edebilmek için alternatif olarak seçilmiştir.</p>
<blockquote><strong>Belirsiz Terimler</strong></blockquote>
<blockquote>Terminolojiyi geliştirirken hatalı iletişim ve kafa karışıklığı yaratan bazı terimlerle karşılaştık.</blockquote>
<blockquote>Kapsülleme, en çok kafa karışıklığı yaratan terimdir. Var olan kullanımda, kapsülleme teriminin üç farklı anlamı var: Soyutlama için engeller koymak (çn. bilgi gizleme), yabancı bileşenlerin sisteme entegre edilmesi (çn. gevşek veya sıkı bağlılık), farklı kullanıcıların hizmetlere olan erişimlerinin denetlenmesi. (çn. erişim kontrolü) Bu kavramlar için, sırasıyla kapsülleme, gömme ve koruma terimleri önerilmiştir.</blockquote>
<blockquote>Miras terimi de kafa karışıklığına sebep olmaktadır. Mevcut kullanımda mirasın iki temel anlamı vardır: Nesnelerin uygulanımlarının tanımlamalarının paylaşılarak organize edilmesi ve ortak davranış ve arayüzler vasıtasıyla nesnelerin sınıflandırılması. (Bu kavramlar için sırasıyla önerilen kavramlar, uygulanım kalıtımı ve arayüz hiyerarşisidir)</blockquote>
<blockquote>Diğer kafa karıştırıcı iki terim de tür ve sınıf terimleridir. Bu terimler, aynı anda nesnelerin dış arayüzleri veya nesnelerin uygulanımı anlamlarına gelebilmektedirler.</blockquote>
<blockquote>Birden çok anlama gelen şeylerin ayrımını yapmak, temel kavramlara aşina olan kişiler için dahi ince bir ustalık gerektirebilmektedir.</blockquote>
<h4>Korumalı Nesne</h4>
<p>Tanım: Korumalı nesne, belirli istemcilerin kendine olan hizmet taleplerini kısıtlama yeteneğine sahip olan nesnedir.</p>
<p>Örnek: Bir posta kutusu (mailbox) nesnesi, yalnızca belirli bir kişinin read (okuma) isteğine cevap verir.</p>
<p>Eş anlamlılar ve İlgili Terimler: Korumalı nesnelerin erişim kontrolü sağladığı söylenir.</p>
<p>Gerekçe: Bu kavram sıklıkla kapsüllenmiş nesne kavramı ile karıştırılmaktadır. Aslında, bazı sistemler kapsülleme ve koruma için benzer mekanizmalar kullanmaktadırlar. (Korumalı nesnelerin aynı zamanda kapsüllenmiş olmaları da beklenebilir.) Korumalı terimi, işletim sistemleri alanındaki ortak kullanıma dayanarak seçilmiştir.</p>
<h4>3.2 Hizmet talep etme ile ilgili terimler</h4>
<h4>Nesne referansı</h4>
<p>Tanım: Nesne referansı, belirli bir nesneyi, güvenilir bir şekilde tanımlayan bir değerdir.</p>
<p>Örnek: C++’da, bir işaretçi değeri, bir nesne referansı görevi yapar. HP NewWave ortamında, bir belge nesnesinden bir grafik nesnesine yapılan bir bağlantı, bir nesne referansıdır.</p>
<p>Unix dosya sisteminde, dosya adı bir referans değildir, çünkü zamanla dosyanın veya içinde bulunduğu dizinin adı değişebilir.</p>
<p>Eş Anlamlılar ve İlgili Terimler: Nesne referansı, bazen tanıtıcı (handle), nesne tanımlayıcısı (object identifier) veya nesne ismi (object name) olarak da adlandırılabilmektedir.</p>
<h4>İstek</h4>
<p>Tanım: Bir istek, bir hizmetin gerçekleştirilmesi için, bir istemci tarafından gerçekleştirilen eylemdir. Bir istek, istenen hizmeti belirten bir işlemi tanımlar. Bir istek, nesneleri tanımlamak için gerekli olan öz nitelikleri içerir. Bir istek, hizmetin nasıl yapılacağını tek başına belirlemez.</p>
<p>Bir istek bildirildiğinde, bir bağlama (binding) işlemi gerçekte yürütülecek kodu ve kod tarafından erişilecek verileri belirler. Bir isteği yerine getirmenin sonucu, sonuçları istemciye döndürmek olabilir; Sonuçlar istenen hizmet yerine getirilirken, ortaya çıkan olağan dışı durumları içeren durum bilgisi benzeri değerleri de içerebilir.</p>
<p>Örnek: Nesne-yönelimli programlama dilinde,programlama diline özgü bir çağrı biçiminin çalıştırılmasıyla, istek bildirilmiş olur. Nesne yönelimli bir kullanıcı arayüzünde, istekler, farenin belli bir görsel imgenin üzerinde gezinirken, farenin butonuna tıklanmasına benzer, fare hareketleri aracılığıyla bildirilmektedir.</p>
<p>Eş Anlamlılar ve İlişkili Terimler: Smalltalk’da, bir istekte bulunmaya, mesaj gönderme veya mesaj devretme denir. C++’da, bir istek bildirme, üye fonksiyonun çağrılması (member function invocation) olarak adlandırılır. CLOS’da, bir istek yayınlamak jenerik fonksiyon (işlev) çağrısı olarak adlandırılır.</p>
<p>Gerekçe: İki nedenden dolayı, geleneksel “mesaj” terimini kullanmaktan kaçınmaktayız. Birincisi, mesaj göndermenin istemci ve hizmet sağlayıcı tarafından eş-zamanlı yürütülmesi anlamına geldiği yanlış anlaması yaygındır.</p>
<p>Diğeri, bir mesajın işlem yapıldığı tek bir konuma gönderildiği yanlış anlamasıdır. Klasik ve genelleştirilmiş nesne modellerinde tanımlandığı üzere, bu tanım genelleştirilmiş nesne modelleri için hatalı olabilir.</p>
<h4>Jenerik (Genel) İşlem</h4>
<p>Tanım: Jenerik (genel) bir işlem, farklı nesneler için, gözle görülür şekilde farklı davranışlar gösteren, istemciler tarafından keyfi olarak talep edilebilen ve farklı uygulanımları olan bir işlemdir türüdür.</p>
<p>Örnek: Yazdırma işlemi, yazdırılabilir herhangi bir nesneden talep edilebilir, örn. bir doküman</p>
<p>veya bir elektronik tablo.</p>
<p>Eş anlamlılar ve İlgili Terimler: C++’da, jenerik işlemlere, sanal üye (virtual member functions) fonksiyonlar adı verilir. Smalltalk’ta ise aynı kavrama mesaj seçici (message selector) denir. Jenerik İşlem yeteneği, aynı zamanda polimorfizm (çok biçimlilik) ve fonksiyon aşırı yükleme olarak adlandırılmaktadır. (Bakınız statik ve dinamik bağlama.)</p>
<p>Gerekçe: Jenerik kelimesi, hizmetin birçok nesne için ortak olduğu gerçeğini vurgular.</p>
<h4>Arayüz</h4>
<p>Tanım: Bir arayüz, bir nesnenin olası kullanım biçimlerinin tanımıdır. Özellikle, bir arayüz, nesneyi bir öz nitelik olarak tanımlayan bir dizi muhtemel istek anlamına gelir. Bir arayüz tarafından tanımlanan olası kullanımlar anlamlılar ise, “nesne arayüzü sağlamaktadır” denir. Bir arayüz, öz niteliklerin ve dönen sonuçların tür ve isteklerin davranış tanımlarını yapabilir. Bir nesnenin <em>temel arayüzü (principal interface)</em>, nesnenin olası tüm kullanımlarını açıklayan bir arayüze verilen addır.</p>
<p>Örnek: Bir yığın arayüzü push ve pop işlemlerinden oluşabilir. Sadece tamsayı türünden verilerin yığına push işlemi aracılığıyla eklenmesine olanak veriyor olabilir. (Bakınız: Yığın örnek işlemleri)</p>
<p>Eş anlamlılar ve İlgili Terimler: Protokol terimi, sıklıkla, nesnelere gönderilmesi mümkün bir mesaj kümesini tanımlamak için kullanılır. Öz nitelik ve sonuç türlerini tanımlayan bir arayüze imza (signature) denir.</p>
<p>Birçok nesne yönelimli programlama dilinde, bir arayüz, soyut sınıf veya sanal sınıf tarafından tanımlanır ve bu sınıf uygulanım-tabanlı bilgiyi (ör. Işlev kısımları — procedure bodies ) önemsemez ve doğrudan uygulanımları mümkün değildir. Tür olarak kullanılan bir arayüze, arayüz-tür (interface type) denir.</p>
<h4>Arayüz Hiyerarşisi</h4>
<p>Tanım: Arayüz hiyerarşisi, arayüzlerin ve dolayısıyla nesnelerin arayüz uygunluğu (object-conformance) terimlerine göre sınıflandırılmasıdır. Bir arayüz, eğer birinci arayüze uygun olan nesne, mutlaka ikinci arayüze de uygun ise, diğer arayüze uygundur.</p>
<p>Örnek: Kuyruk ve yığın veri yapılarının ikisi de, tek bir verinin tek bir seferde eklenebildiği veri havuzları olarak düşünülürler. Yığın arayüzü push ve pop isteklerinden oluşur. Kuyruk arayüzü ise, push ve pull steklerinden oluşur. Bu iki yapının paylaştığı hizmet havuz (sink) arayüzüdür ki, sadece push isteğinden oluşur. Yığın ve kuyruk arayüzlerinin her ikisi de havuz arayüzünü sağlamaktadır. Havuz arayüzünü sağladığı varsayılan nesnelerle çalışan (yani nesnelere sadece push isteği gönderen) bir program, yığın ve kuyruk nesneleriyle çalışabilir. (Yığın ve kuyruk örneklerine bakınız.)</p>
<p>Eş Anlamlılar ve İlgili Terimler: Arayüz hiyerarşilerine, belirtim hiyerarşileri de denir. Arayüz uygunluğunun bir kalıtım mekanizması kullanılarak tanımlandığı sistemlerde, arayüz hiyerarşisine bazen kalıtım hiyerarşisi denir; bununla birlikte, bu kavram için kalıtım (miras) terimini kullanılmasını önermiyoruz. (aşağıda uygulanım mirasına bakınız). Arayüzlerin tür olarak kullanıldığı sistemlerde, arayüz hiyerarşisine, tür hiyerarşisi veya alt-tür hiyerarşisi denilebilir. C++ gibi, arayüzlerin, uygulanımlarından ayrılmadığı sistemlerde, arayüz hiyerarşisine, sınıf hiyerarşisi de denilebilir.</p>
<p>Gerekçe: Kalıtım (miras) teriminin birçok kullanımından biri, arayüz hiyerarşisine gönderme yapmaktadır. Kalıtım kelimesini, özellikle arayüz uygulanımında sınıflandırma termininden ayırmak için, birikimli bir tanımlama mekanizması anlamına gelmesi için kısıtlamayı seçtik.</p>
<p>Arayüz kalıtımı terimi, nesnelerin, istemciler tarafından görülebilen davranışlarına (hizmetlerine) göre sınıflandırılmasını vurgulamaktadır. Arayüz uygunluğuna dayalı sınıflandırma, katı bir hiyerarşi oluşturmamalıdır; Bununla birlikte, hiyerarşi terimi, kafes (lattice) gibi diğer daha teknik terimlere nazaran daha yaygın olarak kullanılması ve anlaşılması avantajına sahiptir.</p>
<h4>Tür</h4>
<p>Tanım: Tür, anlamlı kullanımları karakterize eden değerlerin sınıflandırılmasıdır. Özellikle, bir tür, türe uyan değer kümesini tanımlayan bir beyan anlamına gelir (türün uzantısı olarak adlandırılır). Her nesne sistemi kendi anlamlı kullanım ve tür eğilimin tanımlamaktadır. Türlere sahip olan nesne yönelimli bir sistemde, öz niteliklerin ve isteklerin sonuçlarının belli sınırlar içerisinde olması, türler tarafından karakterize edilmektedir.</p>
<p>Örnek: Türlere sahip olan nesne-yönelimli programlama dili, değişkenleri için tür tanımlamaları sunmaktadır. Bir değişken, sadece beyan edilen türü sağlayan değerleri ifade edebilir. Nesne türleri, örneğin arayüz terimleri kullanılarak (yazdır işlemini destekleyen tüm nesneler) veya uygulanım terimleri (stack-as-list yani liste-bazlı-yığın uygulanımına sahip olan nesnelerin türü), gibi farklı şekillerde ifade edilebilir. Türlere sahip birçok nesne-yönelimli programlama dilinde, arayüz ve uygulanım türlerini tanımlamak için tek bir sınıf yapısı kullanılmaktadır.</p>
<p>Eş anlamlılar ve İlgili Terimler: Sınıf terimi genellikle tür yerine, özellikle nesne uygulanımlarının tür kavramının tek gösterimi olduğu Smalltalk gibi sistemlerde kullanılır.</p>
<h4>Alt-tür</h4>
<p>Tanım: Bir türün (üst-sınıf) alt-türü, alt-türün koşullarını sağlayan her değerin, üst-türün koşullarını da mutlaka sağladığı türdür. Arayüzlerin tür kavramına tekabül ettiği sistemlerde, arayüz uygunluğu (interface conformance) bir alt-tür ilişkisine örnektir.</p>
<p>Örnek: Çalışan kavramı, kişi kavramının alt türüdür: her çalışan nesnesi, aynı zamanda kişi nesnesidir. Jenerik bir işlem, belirli bir türden nesnelerine uygulanması için tanımlanır. Bu işlem, aynı zamanda, belirli bir türün alt-türlerine de uygulanabilir.</p>
<p>Eş anlamlılar ve İlgili Terimler: Uygulanım kalıtımının alt-tür yaratmanın tek yolu olduğu sistemlerde, alt-tür, alt-sınıf veya türemiş sınıf olarak adlandırılmaktadır.</p>
<h4>Dinamik Bağlama</h4>
<p>Tanım: Dinamik bağlama, istenen bir hizmeti gerçekleştirmek için talep bildirildiği anda yapılan kod seçimidir.</p>
<p>Örnek: Smalltalk’da her istek hedef nesne için uygun olan metodu bulmak için, sınıf hiyerarşisi incelenerek işlenmektedir. Sınıf hiyerarşisinde metod eklemek ya da yeniden tanımlamak gibi yapılacak her değişiklik, devam eden istekler için anında etkinlik kazanır.</p>
<p>Eş Anlamlılar ve İlgili Terimler: Dinamik bağlama aynı zamanda geç bağlama olarak da adlandırılır.</p>
<h4>Statik Bağlama</h4>
<p>Tanım: Statik bağlama, istenen bir hizmeti gerçekleştirmek için kullanılan kod seçiminin önceden yapılmış olması durumudur. Statik bağlamayı destekleyen sistemler, azaltılmış genelleme ve genişletilebilirlikten ödün vererek, daha iyi performans ve iyileştirilmiş hata denetimi sınarlar.</p>
<p>Örnek: C ++’da, işaretçi veya referans olmayan bir değişken, belirli bir sınıfa ait (o sınıftan türemiş olmayan) bir nesneyi ifade etmesiyle tanınır; bu değişken üzerindeki bir sanal üye fonksiyonunun çağrılması, belirli bir prosedür üzerinde doğrudan bir çağrı olarak derlenebilir.</p>
<p>Eş Anlamlılar ve İlgili Terimler: Statik bağlama, erken bağlama olarak da adlandırılır.</p>
<h4>3.3 Hizmet sunumuyla ilgili terimler</h4>
<h4>Nesnenin Uygulanımı</h4>
<p>Tanım: Bir nesne uygulaması, bir nesneyle ilişkili hizmet kümesinin nasıl yürütüleceğinin yürütülebilir bir açıklamasıdır. Nesne ile ilişkili verilerin biçimini ve hizmetlerin veriyi nasıl değiştirdiğini tanımlamaktadır. Birden fazla nesne ortak bir uygulanımın parçalarını paylaşabilir; yürütülebilir kod nesneler arasında paylaşılsa da, her nesne tipik olarak verilerin kendi kopyasına sahiptir.</p>
<p>Örnek: Bir daire nesnesi, dairenin durumunu iki durum değişkeni ile tanımlıyor olabilir: Merkez ve çap. Ayrıca daire nesnesi genişle ve yer değiştir adında iki metoda da sahip olabilir.</p>
<p>genişle(çarpan) çap := çap*çarpan;</p>
<p>yer değiştir (yer değiştirme miktarı) := merkez + yer değiştirme miktarı;</p>
<p>Eş Anlamlılar ve İlgili Terimler: Bir nesne uygulanımı tarafından verilen veri biçimi bazen şablon olarak adlandırılır. Birden fazla nesnenin uygulanımına bazen yönetici veya sunucu denir. Bir sınıf, ortak bir uygulanımı paylaşan birden fazla nesne oluşturmak için örneklendirilebilen bir nesne uygulanımıdır; Nesneler sınıfın örnekleri olarak adlandırılır. Bir Fabrika, nesneler yaratmak için hizmet sağlayan bir nesnedir; Bu nedenle sınıf nesnesi de bir fabrikadır.</p>
<h4>Durum Değişkeni</h4>
<p>Tanım: Durum değişkeni, nesnelerle ilişkili verilerin somut gerçekleşimi olarak görev yapan bir değişkendir. Bir durum değişkeni, tek bir nesneyle veya birden çok nesneyle ilişkilendirilebilir. Durum değişkenleri, nesne uygulamalarında sıklıkla bu durum değişkenlerini okuyabilen ve yazabilen yöntemlerle tanımlanır.</p>
<p>Eş Anlamlılar ve İlgili Terimler: Durum değişkenleri aynı zamanda örnek değişkenleri, veri üyeleri, alanlar, özellikler veya oluklar (slots) olarak da adlandırılır</p>
<p>Gerekçe: Bir durum değişkeni, zamana bağlı olarak değişen davranışın uygulanımını gerçekleştiren bir araç olduğunu, nesnelerin istemci tarafından görülebilen davranışına karşıt olarak vurgular. Örnek değişkeni terimi, örneklendirilemeyen olmayan nesneler için uygun değildir.</p>
<h4>Metod</h4>
<p>Tanım: Metod, hizmetleri gerçekleştiren bir işlemdir. Tipik olarak, bir nesnenin desteklediği her işlem için bir metodu (yöntemi) vardır. Metodlar, nesne uygulanımlarında, sıklıkla okumakta ve yazmakta oldukları durum değişkenleriyle birlikte tanımlanmaktadır.</p>
<p>Eş anlamlılar ve İlgili Terimler: C ++’da, metodlara üye fonksiyon tanımları denir.</p>
<h4>Uygulanım kalıtımı</h4>
<p>Tanım: Uygulanım kalıtımı (kolaylık sağlamak için burada sadece kalıtım denmiştir), nesne uygulamalarını aşamalı olarak oluşturmak için varolan bir mekanizmadır: bir nesne, diğer nesnelerin uygulanımlarına bağlı olarak tanımlanmaktadır. Yeni uygulanım, varolan nesneleri, nesne gösterimine (veri biçimi) veri ekleyerek, yeni işlemler ekleyerek ve var olan işlemlerin tanımlarını değiştirerek veya genişleterek genişletebilir.</p>
<p><strong>Nesnenin Diğer Tanımları</strong></p>
<p>Diğer yazarlar, nesne yönelimli programlama dillerinin temel kavramlarını belirlemeye çalışmaktadırlar:</p>
<ul>
<li>Sterik ve Bobrow, bir nesneyi, hesaplama yapan ve durum kaydeden bir varlık olarak tanımlarlar. Nesne-yönelimli programlama dillerindeki çeşitliliği kabul etmekle beraber, iki kavramı temel kavramlar olarak tanımlamaktadırlar: mesaj gönderimi (jenerik işlem talepleri) ve uzmanlaşma (uygulanım kalıtımı) ve ortak olarak sınıflara sahip olma. (örneklendirilebilen uygulanıma sahip nesneler) Mesaj gönderme, soyutlamanın açık doğasından bahsetmeseler de, veri soyutlamayı desteklemek olarak tanımlanır ve kapsüllemeye sadece kısaca değinilir. Nesne davranışı protokoller (arayüzler) açısından tanımlanmıştır, ancak arayüz uygunluğu açıklanmamaktadır. Nesne kimliklendirme açıkça ele alınmamıştır. Stefik ve Bobrow, metod özelleşmesinde ve birleşiminden, bileşik nesnelerden, perspektiflerden, ek açıklamalardan, aktif değerlerden ve meta-sınıflardan da bahsetmektedirler.</li>
<li>Wegner, nesne yönelimli veri soyutlama dilini, nesneleri (yerel bir durumu paylaşan bir işlem kümesi), sınıfları (bir veya daha fazla arayüzü tanımlayan bir örneklenebilir uygulanımı), sınıf kalıtımını ve bilgi gizlemeyi (kapsülleme) desteklemek olarak tanımlar. Jenerik işlemler kavramı, soyutlamanın apaçık doğası, nesne kimliklendirme ve arayüz uygunluğu ve sınıf kalıtımı arasındaki ayrım atlanmıştır. (Alt türleme, tür olan sınıf bağlamında açıklanmaktadır.) Wegner aynı zamanda, kesin türlendirmeden, eş zamanlılıktan, dağıtımdan ve kalıcılıktan nesne-yönelimli programlama dillerini ayrıt eden özellikler olarak bahsetmektedir..</li>
<li>Thomas, nesne yöneliminin dört anahtar kavramını şöyle tanımlamaktadır: kapsülleme, mesaj gönderme (genel işlemler için istekler), sınıf kalıtımı ve bağlama (statik ve dinamik). Nesneleri, gerçek dünyadaki varlıkların, kendini açıklayan (apaçık soyutlama) benzeşenleri (analog) olarak tanımlar. Sınıfları (örnek üretilebilen uygulanımları) ve mantıksal bir sınıf hiyerarşini açıklar; (tıpkı bir arayüz hiyerarşisinin arayüzü ile ilgili olması gibi) sınıfları dış davranışa bağlı olarak ilişkilendirir. Arayüzlerden bahsetmez. Sınıflar türlerle tanımlanır ve alt türleme, davranış koruyan sınıfı kalıtımı (uygulanım kalıtımı) olarak tanımlanır. Nesnenin kimliklendirilmesi ele alınmamıştır. Thomas ayrıca meta-sınıflardan, bileşik nesnelerden ve özel mesajlardan (erişim denetiminin bir biçimi olarak) bahseder.</li>
<li>Wand, nesnelerin mantıklı durumlarını ve durum dönüşümlerini sınırlandıran bir yasaya bağlı olarak, hizmetler ve istekler kavramlarının, genel bir nesne etkileşimi kavramı ile değiştirildiği resmi bir nesne modeli sunmaktadır. Wand’ın görüşüne göre, istekler ve işlemler nesne etkileşimlerinin uygulanımıdır. Wand’ın modeli nesne yaratımını da atlamaktadır.</li>
</ul>
<p>Bizim nesne tanımımız varolan tanımlamaların çoğundan şu şekilde farklıdır: Bir nesnenin duruma sahip olmasını gerekli olduğunu düşünmüyoruz. Her hesaplama varlığının bir nesne olmasını gerektiğini düşünmüyoruz. Bize göre, tek tek nesnelerle ilişkili olmayan veya birden çok nesneyle paylaşılan durum mümkündür. İsteklerin birden çok nesneyi içermesine ve üçüncü taraflar tarafından gerçekleştirilmesine izin veriyoruz. Bu genellemeler daha geniş bir nesne sistemi yelpazesini belirlemek içindir. Ayrıca, bizim tanımımız nesne kimliklendirmeyi, jenerik işlem kavramını ve hizmetler ve uygulanımlar arasındaki ayrımı (arayüzler) ve arayüz hiyerarşisi (sınıflandırma) ile uygulanım mirası (yapım) arasındaki ayrımı vurgulamaktadır. Belki de en önemlisi, yalnızca programlama dilleri için değil, birçok alana uygun terim ve tanımları kullanmaya çalışıyoruz.</p>
<p>Tekli kalıtım, bir nesne uygulanımının, tek bir varolan nesne uygulanımı açısından tanımlanmasına izin verir. Çoklu kalıtım, yeni bir nesnenin tanımlanmasında birden fazla nesne uygulanımı kullanılmasına izin verir. Kalıtım, genellikle bir sınıfın diğer sınıflardan miras aldığı sınıfsal kalıtımı biçimini alır.</p>
<p>Kalıtım, bir nesnenin veya sınıfın metinsel tanımını kopyalayarak ve düzenleyerek, yeni bir tanım üretmek için etkilidir; ancak eski tanımdaki değişiklikler (sonuç olarak) yeni tanıma yayılır. Ayrıca kalıtım, nesne uygulanımlarını bir kalıtım hiyerarşisinde organize etmenin bir yolunu sunmaktadır.</p>
<p>Örnek: Başlıklı Pencere gibi bir isme sahip olan bir sınıf, pencere sınıfından miras alınacak şekilde tanımlanabilir. Başlıklı pencere sınıfı, bir başlık örnek değişkeni ve başlık ile ilgili işlemlerin (başlığı döndürmek için, başlık işlevi) (başlığı düzenlemek için başlık-düzenle işlevi) uygulanımını sağlayan prosedürleri tanıma ekleyecektir.</p>
<p>Eş anlamlılar ve İlgili Terimler: Kalıtımı, birikimli tanımlama için herhangi bir mekanizma olarak tanımlamaktayız. Kalıtım ile tanımlanan bir sınıf, tanımlanmasında kullanılan sınıfların alt sınıfı olarak adlandırılır ve buna üst sınıflar denir. C++’da, alt sınıf, türetilmiş sınıf olarak da adlandırılır ve bir üst sınıf, taban sınıf olarak adlandırılır. Bir devralma hiyerarşisine, uygulanım hiyerarşisi veya sınıf hiyerarşisi de denir.</p>
<p>Gerekçe: Kalıtım, birçok türde hiyerarşiye göndermede kullanılan yaygın bir terimdir. Nesne yönelimli sistemlerde öncelikle arayüz hiyerarşilerine ve birikimli tanım mekanizmalarına değinmek için kullanılır. Kalıtım terimini, bir ilişkiden ziyade, kalıtım kelimesinin günlük kullanımına uygun olarak, bir işlemi belirtmek için kullanılan ikinci kavram (çn. birikimli artım mekanizması) olarak sınırlamaktayız.</p>
<h4>4 Teşekkürler</h4>
<p>HP object task force grubunun üyelerine bu çabaya olan katkılarından ve Walter Olthoffand ve Walt Hill’in yardımlarından dolayı teşekkür ediyoruz. Ayrıca, Hewlett-Packard çalışanlarına ve önceki belgeleri inceleyen ve önerilerinde iyileştirmeler sağlayan Nesne Yönetimi Grubu teknik komitesinin üyelerine de minnettarız. Katkılarından ötürü Bill Kent’e özellikle minnettarız.</p>
<h4>5 Referanslar</h4>
<p>1. D. G. Bobrow, L. G. DeMichel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. Common Lisp Object System Specification X3J13. SIGPLANNotices 23, 9 (1988).<br>2. I. J. Fuller, et al. An Overview of the HP NewWave Environment. HP Journal 40, 4 (Aug. 1989), 6–23.<br>3. J. Johnson, et al. The Xerox Star: A Retrospective. Computer 22, 9 (Sept. 1989), 11–29.<br>4. M. R. Cagan. The HP SoftBench Environment: An Architeeture for a New Generation ofSoftware Tools. HP Journal 41, 3 (June 1990), 36–47.<br>5. D. H. Fishman, et al. Iris: An Object-Oriented Data Base System. ACM Transactions on Office Information Systems 5, 1 (1987), 48–69.<br>6. S. McKay, W. York, and M. McMahon. A Presentation Manager Based on Application Semantics. Proc. ACM Symposium on User Interface Software and Technology, Nov. 1989, 141–148.<br>7. ISO. Information Technology -Open Systems Interconnection -ManagementInformation Services -Structure ofManagement Information -Part 1: Management Information Model. Draft International Standard 10165–1. ISOIIEC JTCl/SC21 N5252, June 1990.<br>8. R. M. Soley, ed. Object Management Architecture Guide. Object Management Group, Inc. Framingham, Ma., October 1990.<br>9. P. Wegner. Learning the Language. Byte, March 1989,245–253.<br>10. D. Thomas. What’s in an Object? Byte, March 1989, 231–240.<br>11. M. Stefik &amp; D. G. Bobrow. Object-Oriented Programming: Themes and Variations. AIMagazine 6, 4 (Winter 1986), 40–62.<br>12. Y. Wand. A Proposal for a Formal Model of Objects. In Object-Oriented Concepts, Databases, and Applications. W. Kim, F. H. Lochovsky, eds. ACM Press, 1989, 537–559.</p>
<hr>

<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2016/12/cceb0-14uozfs7kywroi5ep-uyz5g.jpeg">

<figcaption class="wp-caption-text"><em>Projelerle PHP 7</em></figcaption></figure><p><em>Ben </em><a href="http://mynameismidori.com" target="_blank"><strong><em>Mutlu Koçak</em></strong></a><em>, Bilgisayar Mühendisiyim, ZCPE Sertifikasına sahibim ve “</em><a href="https://www.seckin.com.tr/kitap/911934237" target="_blank"><em>Hiç Bilmeyenler İçin İnternet Programlamaya Giriş — PHP 7</em></a><em>” adlı kitabın yazarıyım. Kitabım: </em><a href="https://www.seckin.com.tr/kitap/911934237" target="_blank"><em>https://www.seckin.com.tr/kitap/911934237</em></a><em><br>Özgeçmişim: </em><a href="http://represent.io/mtkocak.pdf" target="_blank"><em>http://represent.io/mtkocak.pdf</em></a><em> <br>Websitem: </em><a href="http://mynameismidori.com" target="_blank"><em>http://mynameismidori.com</em></a></p>