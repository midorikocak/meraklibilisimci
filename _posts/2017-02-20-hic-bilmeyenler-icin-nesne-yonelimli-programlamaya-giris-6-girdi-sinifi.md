---
ID: 61
post_title: >
  Hiç Bilmeyenler İçin Nesne Yönelimli
  Programlamaya Giriş-6— Girdi
  Sınıfı
author: Midori Kocak
post_excerpt: ""
layout: post
permalink: >
  https://www.meraklibilisimci.com/hic-bilmeyenler-icin-nesne-yonelimli-programlamaya-giris-6-girdi-sinifi/
published: true
post_date: 2017-02-20 12:47:04
---


<p>Bu yazı daha önce yazdığım <a href="https://medium.com/turkce/hi%C3%A7-bilmeyenler-i%CC%87%C3%A7in-nesne-y%C3%B6nelimli-programlamaya-giri%C5%9F-5-s%C4%B1n%C4%B1f%C4%B1-in%C5%9Fa-etmek-83036f340215#.qtufdd74e" target="_blank">Hiç Bilmeyenler İçin Nesne Yönelimli Programlamaya Giriş-5</a> yazısının devamıdır. Önce onu okumanızı öneririm.</p>
[embed]https://medium.com/turkce/hi%C3%A7-bilmeyenler-i%CC%87%C3%A7in-nesne-y%C3%B6nelimli-programlamaya-giri%C5%9F-5-s%C4%B1n%C4%B1f%C4%B1-in%C5%9Fa-etmek-83036f340215[/embed]
<p>Bir önceki yazıda girdi sınıfımızı kullanan sözlük sınıfımızı yazdık. Deneme/Yanılma yani Try/Catch bloklarını kullanarak hatalara dayanıklı kod yazmayı ve kod tekrarlarını önlemekten bahsettik. Bu yazıda Entry yani girdi sınıfımızı oluşturacağız.</p>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/04ef1-1yl1f3fsucadb86i5c6r6gw.jpeg">

<figcaption class="wp-caption-text">Sözlük girdisi</figcaption></figure><p>Dictionary.php sınıfımızın bulunduğu dizinde Entry.php adlı bir dosya oluşturalım. Artık bir sınıfın aşağı yukarı nasıl olması gerektiğini biliyorsunuz. İçi boş sınıfımızı şu şekilde yazalım.</p>
<pre><strong>&lt;?php<br><br>namespace </strong>MidoriKocak;<br><br><br><strong>class </strong>Entry <strong>implements </strong>EntryInterface<br>{<br><strong>public function </strong>__construct(){}<br><strong>public function </strong>setKey(string $key){}<br><strong>public function </strong>getKey(): string{}<br><strong>public function </strong>setValues(<strong>array </strong>$values){}<br><strong>public function </strong>getValues(): <strong>array</strong>{}<br><strong>public function </strong>getValue(int $order): string{}<br><strong>public function </strong>setValue(int $order, string $newValue){}<br><strong>public function </strong>addValue(string $value){}<br><strong>public function </strong>deleteValue(int $order){}<br>}</pre>
<p>Her sınıfın __construct metodu olması gerektiğine dikkat edelim. Diğer metodlar daha önce EntryInterface.php içinde isimlerini tanımladığımız metodlar olacak. Tek tek metotlarımızın içlerini doldurmaya başlamadan önce, sınıfa özel private, yani sadece sınıfın içinden erişebileceğimiz değişkenleri sınıfımızın koduna eklemeye başlayalım.</p>
<p>__construct yani sihirli yaratma metodundan önce değişkenleri sınıfa şu şekilde ekleyelim:</p>
<pre><strong>&lt;?php<br><br>namespace </strong>MidoriKocak;<br><br><br><strong>class </strong>Entry <strong>implements </strong>EntryInterface<br>{<br><strong>private $key</strong>;<br><strong>private $values</strong>;<br><br><strong>public function </strong>__construct(string $key, string $value)<br>    {<br>        $this-&gt;setKey($key);<br>        $this-&gt;<strong>values </strong>= [];<br><em>array_push</em>($this-&gt;<strong>values</strong>, $value);<br>    }</pre>
<p>Yaptıklarımızı her zaman yaptığım gibi tek tek açıklayayım:</p>
<ol>
<li>Sınıfımıza private yani özel tipinde, $key ve $values adlı iki değişken ekledik.</li>
<li>$key burada metin tipinde girdinin başlığını tutacak. Her başlıkta olduğu gibi, boş olmayacak ve 70 karakterden uzun olmayacak. Buna benzer kontrolü, Dictionary.php dosyasında setTitle metodunda yapmıştık. Aynı metodu alıp biraz değiştirerek burada kullanacağız.</li>
<li>$values değişkeni, girdinin sahip olduğu açıklamaları tutan diziyi içerecek.</li>
<li>__construct metodu içinde parametre olarak $key ve $value adlı iki değer tanımladık ki, girdi sınıfımızı, kolaylık açısından, örneğin $entry = new Entry(‘nesne’, ‘harika bişi’); diyerek yaratabilelim.</li>
<li>__construct sınıfımızın içine baktığımızda, tıpkı Dictionary.php dosyasındaki __construct metodundaki setTitle metodunda olduğu gibi, setKey adlı metod ile $key değişkenini belirliyoruz ve bu sayede $key değişkeninin boş olmadığını, yani “” değerinde bir metin olmadığını ve 70 karakterden kısa olduğundan emin olarak nesnemizi yaratıyoruz.</li>
<li>$this-&gt;values = [] diyerek boş bir dizi oluşturuyoruz.</li>
<li>array_push metodu ile aldığımız $value değerini doğrudan $values dizisinin içerisine, sıra numarası olmadan ekliyoruz. Daha sonra addValue metodunun içini doldurduğumuzda bu satırı değiştirmeliyiz. <strong>Önemli: </strong>Uymamız gereken önemli bir kural olarak değişkenlere her zaman, o değişkenleri değiştiren ilgili set/get veya add metodları ile erişmeli veya manipüle etmeliyiz.</li>
</ol>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/2a07a-1fbdho6bnfehyc9fx21jhua.jpeg">

<figcaption class="wp-caption-text">Getter ve Setter metodlarını bankadaki veznedar gibi düşünebilirsiniz.</figcaption></figure><h4>Erişici ve Değiştirici yani Setter ve Getter metotları</h4>
<p>Sınıfımızın metodlarının içlerini doldurmaya devam edelim:</p>
<pre><strong>public function </strong>setKey(string $key)<br>{<br><strong>try </strong>{<br><strong>if </strong>(($key != <strong>""</strong>) &amp;&amp; (<em>strlen</em>($key) &lt;= 70)) {<br>            $this-&gt;<strong>key </strong>= $key;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Wrong key title.'</strong>);<br>        }<br>    } <strong>catch </strong>(Exception $e) {<br><strong>echo </strong>$e-&gt;getMessage();<br>    }<br>}<br><br><strong>public function </strong>getKey(): string<br>{<br><strong>return </strong>$this-&gt;<strong>key</strong>;<br>}</pre>
<p>setKey ve getKey metodları, daha önce Dictionary.php yani sözlük sınıfımızdaki setTitle ve getTitle metodlarında olduğu gibi, değişkeni kurallarımıza uyarak değiştirmemizi ve erişimi kontrol etmemizi sağlıyorlar. Burada getKey metodu doğrudan değişkeni döndürmekte. Fakat daha sonra, örneğin, erişimi bir şekilde kontrol etmek istersek (Örneğin sadece yazının yazarının erişebildiği bir yazı gibi), bu metodu değiştirebiliriz. Aklımızda bulunsun. Yine try/catch blokları ile hata denetimi yaptık.</p>
<pre><strong>public function </strong>setValues(<strong>array </strong>$values)<br>{<br><strong>try </strong>{<br><strong>if </strong>(!<strong>empty</strong>($values)) {<br>            $this-&gt;<strong>values </strong>= $values;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Array cannot be empty.'</strong>);<br>        }<br>    } <strong>catch </strong>(Exception $e) {<br><strong>echo </strong>$e-&gt;getMessage();<br>    }<br>}<br><br><strong>public function </strong>getValues(): <strong>array<br></strong>{<br><strong>return </strong>$this-&gt;<strong>values</strong>;<br>}</pre>
<p>Tıpkı setKey ve getKey metotlarında olduğu gibi gelen değerleri kontrol ettik. Burada gelen dizinin boş olmamasını kontrol ediyoruz. Fakat, dizinin tek boyutlu ve her elemanının metin tipinde olduğunu tek tek kontrol etmemiz gerekirdi. Şimdilik kolaylık açısından bunu daha sonraya bırakalım.</p>
<pre><strong>private function </strong>isOrderInValues($order): bool<br>{<br><strong>try </strong>{<br><strong>if </strong>(!<em>array_key_exists</em>($order, $this-&gt;<strong>values</strong>)) {<br><strong>throw new </strong>OutOfBoundsException(<strong>'Cannot find entry in dictionary'</strong>);<br>        } <strong>else </strong>{<br><strong>return true</strong>;<br>        }<br>    } <strong>catch </strong>(Exception $e) {<br><strong>echo </strong>$e-&gt;getMessage();<br>    }<br><strong>return false</strong>;<br>}</pre>
<p>Daha önce Dictionary.php sınıfında, bir anahtarın dizide olup olmadığını kontrol eden ve hata döndüren isKeyInEntries($key) metodu yazmıştık. Burada da isOrderInValues metodu ile aynı şeyi yapıyoruz ki olmayan bir değere erişim sağlamaya çalışan bir gerizekalı programımızı çökertmesin.</p>
<pre><strong>public function </strong>setValue(int $order, string $newValue)<br>{<br><strong>if </strong>($this-&gt;isOrderInValues($order)) {<br>        $this-&gt;<strong>values</strong>[$order] = $newValue;<br>    }<br>}<br><br><strong>public function </strong>getValue(int $order): string<br>{<br><strong>if </strong>($this-&gt;isOrderInValues($order)) {<br><strong>return </strong>$this-&gt;<strong>values</strong>[$order];<br>    }<br><strong>return ""</strong>;<br>}<br><br><strong>public function </strong>addValue(string $value)<br>{<br><em>array_push</em>($this-&gt;<strong>values</strong>, $value);<br>}<br><br><strong>public function </strong>deleteValue(int $order)<br>{<br><strong>if </strong>($this-&gt;isOrderInValues($order)) {<br><strong>unset</strong>($this-&gt;<strong>values</strong>[$order]);<br>    }<br>}</pre>
<p>Kalan metodlarımızı da tek tek açıklayalım:</p>
<ol>
<li>
<strong>setValue:</strong> Sıra numarası ile açıklamayı düzenleyen metot. Bu metot aslında istediğimiz değerleri sıra numarası ile erişip düzenlememize yarıyor. Yine isOrderInValues metodu ile o sıra numarasında değer olup olmadığını kontrol ettik.</li>
<li>
<strong>getValue:</strong> Sıra numarası ile açıklamayı döndürüyor.</li>
<li>
<strong>addValue:</strong> Sıra numarası kullanmadan doğrudan $values değişkeninin yani açıklamalar dizisinin sonuna istediğimiz değeri ekliyor.</li>
<li>
<strong>deleteValue:</strong> Sıra numarası girerek açıklamayı silmemizi sağlıyor.</li>
</ol>
<p>AddValue ve setValue metotlarında, açıklamanın zaten ekli olup olmadığını da kontrol edebilirdik, ancak bunu da şimdilik kolaylık açısından geçiyorum. Arama kısmına geldiğimizde, bu konuyu detaylı olarak anlatacağım.</p>
<figure>

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/0e108-1lgal7k0uwip0kt6espne_g.jpeg">
</figure><p>Girdi yani Entry sınıfımızı tanımlamayı bitirdik. Gelelim kodumuzu kullanacak kodu yazmaya. Aynı dizinde daha önceden yazdığımız app.php isimli dosyayı şu şekilde değiştirelim:</p>
<pre><strong>&lt;?php<br><br>require_once 'DictionaryInterface.php'</strong>;<br><strong>require_once 'Dictionary.php'</strong>;<br><strong>require_once 'EntryInterface.php'</strong>;<br><strong>require_once 'Entry.php'</strong>;<br><br>$dictionary = <strong>new </strong>MidoriKocakDictionary(<strong>"Nesne Yönelimli Programlama Sözlüğü"</strong>);<br><br>$nesne = <strong>new </strong>MidoriKocakEntry(<strong>'nesne'</strong>, <strong>'aklımızın dışındaki herşey'</strong>);<br><br>$nesne-&gt;addValue(<strong>'harika bişi'</strong>);<br>$nesne-&gt;addValue(<strong>'ingilizce object'</strong>);<br><br>$şey = <strong>new </strong>MidoriKocakEntry(<strong>'şey'</strong>, <strong>'ismi olmayan nesne'</strong>);<br><br>$dictionary-&gt;addEntry($nesne);<br>$dictionary-&gt;addEntry($şey);<br><br>$entries = $dictionary-&gt;getEntries();<br><br><em>print_r</em>($entries);</pre>
<p>Burada print_r metodu, dizileri insanların okuyacağı şekilde ekrana basan metoddur. Eğer herhangi bir sorun olmazsa, web sunucumuzdan app.php adlı dosyayı çağırdığımız zaman şöyle bir sonuçlar karşılaşacağız:</p>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/6bcbd-1kog2ozxdobhbfsa5zyojeq.png">

<figcaption class="wp-caption-text">Ne kadar çok chrome extension yüklemişim yahu.</figcaption></figure><p>Sonuç olarak elimizde doğru dürüst çalışan tertemiz iki sınıfımız oldu.</p>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/d1c2d-1zsbvxabagp0ubsokbr-hyw.jpeg">

<figcaption class="wp-caption-text">Hata mesajlarımız anlaşılır ve açık olmalı. Bu nedir yani?</figcaption></figure><p>Peki hata durumunda ne olacak? app.php dosyasını şu şekilde değiştirelim:</p>
<pre><strong>&lt;?php<br><br>require_once 'DictionaryInterface.php'</strong>;<br><strong>require_once 'Dictionary.php'</strong>;<br><strong>require_once 'EntryInterface.php'</strong>;<br><strong>require_once 'Entry.php'</strong>;<br><br>$dictionary = <strong>new </strong>MidoriKocakDictionary(<strong>"Nesne Yönelimli Programlama Sözlüğü"</strong>);<br><br>$nesne = <strong>new </strong>MidoriKocakEntry(<strong>'nesne'</strong>, <strong>'aklımızın dışındaki herşey'</strong>);<br><br>$nesne-&gt;addValue(<strong>'harika bişi'</strong>);<br>$nesne-&gt;addValue(<strong>'ingilizce object'</strong>);<br><br>$şey = <strong>new </strong>MidoriKocakEntry(<strong>''</strong>, <strong>'ismi olmayan nesne'</strong>);<br><br>$dictionary-&gt;addEntry($nesne);<br>$dictionary-&gt;addEntry($şey);<br><br>$entries = $dictionary-&gt;getEntries();<br><br><em>print_r</em>($entries);</pre>
<p>$şey değişkeninde oluşturduğumuz entry nesnesinin başlık bilgisini girmeyi unuttuk. Sonuç ne olacak? Görelim:</p>
<figure>

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/95336-1okl-vu2qysmpej_zy-vm6q.png">
</figure><p>Dikkat. Eğer uncaught error gibi bir hata gördüysek hata try/catch bloklarımızın dışında meydana gelmiş ve biz önlem alamamışız demektir. İnceleyelim. Burada sorun, key değeri boş olmasına rağmen, setKey metodu içinde istisnayı yakaladığımız için kodun çalışmaya devam etmiş olması. Bunu şimdilik setKey metodunu şu şekilde değiştirerek çözelim:</p>
<pre><strong>public function </strong>setKey(string $key)<br>{<br><strong>try </strong>{<br><strong>if </strong>(($key != <strong>""</strong>) &amp;&amp; (<em>strlen</em>($key) &lt;= 70)) {<br>            $this-&gt;<strong>key </strong>= $key;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Wrong key title.'</strong>);<br>        }<br>    } <strong>catch </strong>(Exception $e) {<br><strong>echo </strong>$e-&gt;getMessage();<br><strong>throw new </strong>Exception(<strong>"Cannot create entry"</strong>);<br>    }<br>}</pre>
<p>Sorunu şu anlık çözmek adına catch bloğu içinde kodu durduracak bir istisna fırlattık. Hata kodumuz şu şekilde değişti:</p>
<figure>

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/d271c-1bb8nlo-gckznjqf7cjqvxw.png">
</figure><p>Gördüğümüz gibi kod çalışmaya devam etmedi ve hatanın olduğu yeri tamı tamına bize iletti.</p>
<h4>Hata denetimi kimin sorumluluğunda?</h4>
<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/a39ed-1mxunohvz9f2arjeujyxnvg.png">

<figcaption class="wp-caption-text">Sorumluluk</figcaption></figure><p>Konuyu öğretmek açısından metotlarımızda try/catch bloklarını birlikte metotun içinde kullandık. Ancak, bu hatalara karşı önlem almak bizim sınıfımızın sorumluluğunda değil. Hatayı düzeltmek ve buna karşı önlem almak o kodu hatalı çalıştıran kişinin sorumluluğudur. Sınıf, sadece hatalı durumu belirtecek istisnayı fırlatır ve pisliğini temizle kardeşim der. Ayrıca, catch bloklarını tekrar tekrar metotlar içinde aynı şekilde kullandığımızı farkettiniz. Eğer bir yerde sık sık kod tekrarı oluyorsa, tekrarlanan kodun başka bir yere gitmesi ve oralardan erişilmesi gerekiyor. SOLID ilkelerinden henüz detaylıca bahsetmemiştim, ancak Single Responsibility Principle yani Tek Sorumluluk Prensibine göre her sınıfın iyi yapması gereken tek bir iş var. Bu tek sorumluluğa hata denetimi yapmak girebilir ama kodu kullanan kişinin hatasını temizlemek girmez. O zaman sınıfılarımızdaki try/catch bloklarını kaldıracak ve başka bir yere taşıyacağız. (Not: kitapta örnekleri baştan düzeltmek lazım.)</p>
<p>Yani tryb bloğu içindeki ifadeyi bırakalım, ve kalanını silelim. Örneğin setTitle metodu şöyleydi:</p>
<pre><strong>public function </strong>setKey(string $key)<br>{<br><strong>try </strong>{<br><strong>if </strong>(($key != <strong>""</strong>) &amp;&amp; (<em>strlen</em>($key) &lt;= 70)) {<br>            $this-&gt;<strong>key </strong>= $key;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Wrong key title.'</strong>);<br>        }<br>    } <strong>catch </strong>(Exception $e) {<br><strong>echo </strong>$e-&gt;getMessage();<br><strong>throw new </strong>Exception(<strong>"Cannot create entry"</strong>);<br>    }<br>}</pre>
<p>Bunu şu şekilde değiştirelim:</p>
<pre><strong>public function </strong>setKey(string $key)<br>{<br><strong>if </strong>(($key != <strong>""</strong>) &amp;&amp; (<em>strlen</em>($key) &lt;= 70)) {<br>        $this-&gt;<strong>key </strong>= $key;<br>    } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Wrong key title.'</strong>);<br>    }<br>}</pre>
<p>Gördüğümüz gibi kod artık sadece hata durumunda istisna fırlatıyor, ama bu istisnanın pisliğinin temizlenmesi artık kullanıcının sorumluluğunda. Entry.php ve Dictionary.php içindeki tüm try/catch bloklarını bu şekilde kaldırlarım. Yani try bloğu içindeki kodu dışarı taşıyalım, ve try/catch bloğunu yukarıdaki örnekteki gibi silelim.</p>
<p>Dictionary.php dosyamızın son hali şu şekilde olsun:</p>
<pre><strong>&lt;?php<br><br>namespace </strong>MidoriKocak;<br><br><strong>class </strong>Dictionary <strong>implements </strong>DictionaryInterface<br>{<br><strong>private $title</strong>;<br><strong>private $entries</strong>;<br><br><strong>public function </strong>__construct(string $title)<br>    {<br>        $this-&gt;setTitle($title);<br>        $this-&gt;<strong>entries </strong>= [];<br>    }<br><br><strong>public function </strong>setTitle(string $title)<br>    {<br><strong>if </strong>(($title != <strong>""</strong>) &amp;&amp; (<em>strlen</em>($title) &lt;= 70)) {<br>            $this-&gt;<strong>title </strong>= $title;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Wrong title value.'</strong>);<br>        }<br>    }<br><br><strong>public function </strong>getTitle(): string<br>    {<br><strong>return </strong>$this-&gt;<strong>title</strong>;<br>    }<br><br><strong>public function </strong>getEntries(): <strong>array<br></strong>{<br>        $entries = [];<br><em>/* </em><strong><em>@var </em></strong><em>$entry EntryInterface */<br></em><strong>foreach </strong>($this-&gt;<strong>entries as </strong>$entry) {<br>            $entries[$entry-&gt;getKey()] = $entry-&gt;getValues();<br>        }<br><strong>return </strong>$entries;<br>    }<br><br><strong>public function </strong>setEntries(<strong>array </strong>$entries)<br>    {<br><strong>if </strong>(!<strong>empty</strong>($entries)) {<br>            $this-&gt;<strong>entries </strong>= $entries;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Array cannot be empty.'</strong>);<br>        }<br>    }<br><br><strong>public function </strong>addEntry(EntryInterface $entry)<br>    {<br>        $key = $entry-&gt;getKey();<br>        $this-&gt;<strong>entries</strong>[$key] = $entry;<br>    }<br><br><strong>private function </strong>isKeyInEntries($key) :bool<br>    {<br><strong>if </strong>(!<em>array_key_exists</em>($key, $this-&gt;<strong>entries</strong>)) {<br><strong>throw new </strong>OutOfBoundsException(<strong>'Cannot find entry in dictionary'</strong>);<br>        } <strong>else </strong>{<br><strong>return true</strong>;<br>        }<br>    }<br><br><strong>public function </strong>getEntry(string $key): EntryInterface<br>    {<br><strong>if </strong>($this-&gt;isKeyInEntries($key)) {<br><strong>return </strong>$this-&gt;<strong>entries</strong>[$key];<br>        }<br>    }<br><br><strong>public function </strong>deleteEntry(string $key)<br>    {<br><strong>if </strong>($this-&gt;isKeyInEntries($key)) {<br><strong>unset</strong>($this-&gt;<strong>entries</strong>[$key]);<br>        }<br>    }<br>}</pre>
<p>Entry.php dosyamızın son hali de şu şekilde:</p>
<pre><strong>&lt;?php<br><br>namespace </strong>MidoriKocak;<br><br><br><strong>class </strong>Entry <strong>implements </strong>EntryInterface<br>{<br><strong>private $key</strong>;<br><strong>private $values</strong>;<br><br><strong>public function </strong>__construct(string $key, string $value)<br>    {<br>        $this-&gt;setKey($key);<br>        $this-&gt;<strong>values </strong>= [];<br><em>array_push</em>($this-&gt;<strong>values</strong>, $value);<br>    }<br><br><strong>public function </strong>setKey(string $key)<br>    {<br><strong>if </strong>(($key != <strong>""</strong>) &amp;&amp; (<em>strlen</em>($key) &lt;= 70)) {<br>            $this-&gt;<strong>key </strong>= $key;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Wrong key title.'</strong>);<br>        }<br>    }<br><br><strong>public function </strong>getKey(): string<br>    {<br><strong>return </strong>$this-&gt;<strong>key</strong>;<br>    }<br><br><strong>public function </strong>setValues(<strong>array </strong>$values)<br>    {<br><strong>if </strong>(!<strong>empty</strong>($values)) {<br>            $this-&gt;<strong>values </strong>= $values;<br>        } <strong>else </strong>{<br><strong>throw new </strong>InvalidArgumentException(<strong>'Array cannot be empty.'</strong>);<br>        }<br>    }<br><br><strong>public function </strong>getValues(): <strong>array<br></strong>{<br><strong>return </strong>$this-&gt;<strong>values</strong>;<br>    }<br><br><strong>private function </strong>isOrderInValues($order)<br>    {<br><strong>if </strong>(!<em>array_key_exists</em>($order, $this-&gt;<strong>values</strong>)) {<br><strong>throw new </strong>OutOfBoundsException(<strong>'Cannot find entry in dictionary'</strong>);<br>        } <strong>else </strong>{<br><strong>return true</strong>;<br>        }<br>    }<br><br><strong>public function </strong>setValue(int $order, string $newValue)<br>    {<br><strong>if </strong>($this-&gt;isOrderInValues($order)) {<br>            $this-&gt;<strong>values</strong>[$order] = $newValue;<br>        }<br>    }<br><br><strong>public function </strong>getValue(int $order): string<br>    {<br><strong>if </strong>($this-&gt;isOrderInValues($order)) {<br><strong>return </strong>$this-&gt;<strong>values</strong>[$order];<br>        }<br><strong>return ""</strong>;<br>    }<br><br><strong>public function </strong>addValue(string $value)<br>    {<br><em>array_push</em>($this-&gt;<strong>values</strong>, $value);<br>    }<br><br><strong>public function </strong>deleteValue(int $order)<br>    {<br><strong>if </strong>($this-&gt;isOrderInValues($order)) {<br><strong>unset</strong>($this-&gt;<strong>values</strong>[$order]);<br>        }<br>    }<br>}</pre>
<p>Şimdi app.php dosyamızı da şu şekilde değiştirelim:</p>
<pre><strong>&lt;?php<br><br>require_once 'DictionaryInterface.php'</strong>;<br><strong>require_once 'Dictionary.php'</strong>;<br><strong>require_once 'EntryInterface.php'</strong>;<br><strong>require_once 'Entry.php'</strong>;<br><br><strong>try </strong>{<br>    $dictionary = <strong>new </strong>MidoriKocakDictionary(<strong>"Nesne Yönelimli Programlama Sözlüğü"</strong>);<br><br>    $nesne = <strong>new </strong>MidoriKocakEntry(<strong>'nesne'</strong>, <strong>'aklımızın dışındaki herşey'</strong>);<br><br>    $nesne-&gt;addValue(<strong>'harika bişi'</strong>);<br>    $nesne-&gt;addValue(<strong>'ingilizce object'</strong>);<br><br>    $şey = <strong>new </strong>MidoriKocakEntry(<strong>''</strong>, <strong>'ismi olmayan nesne'</strong>);<br><br>    $dictionary-&gt;addEntry($nesne);<br>    $dictionary-&gt;addEntry($şey);<br><br>    $entries = $dictionary-&gt;getEntries();<br><br><em>print_r</em>($entries);<br>} <strong>catch </strong>(Exception $e) {<br><strong>echo 'Error on line '</strong>.$e-&gt;getLine().<strong>' in '</strong>.$e-&gt;getFile()<br>        .<strong>': &lt;b&gt;'</strong>.$e-&gt;getMessage();<br>}</pre>
<p>Gördüğümüz gibi tüm kullanıcı kodumuzu try/catch bloğu içinde aldık. Artık elimizde tek bir try/catch bloğu var. Üstelik catch bloğu içinde hata mesajımızı da değiştirdik. Bu sayede hatanın olduğu dosyayı, satırı ve mesajı aynı anda görebileceğiz. Eğer bunu metotlar içinde sürekli tekrarlanan try/catch blokları içinde yapsaydık aynı kodu sürekli yapıştırmamız gerekecekti. Unutmayın, eğer bir yerde kod tekrarı varsa, kötü tasarım vardır.</p>
<figure>

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/2571c-1z6vgoaby9e8ljv_l8xlcea.png">
</figure><p>Şimdi hata kodumuzun nasıl göründüğüne bakalım:</p>
<figure>

<img src="https://meraklibilisimcihome.files.wordpress.com/2017/02/aab66-1vkj-kxydxjx_ebf-p2ts3a.png">
</figure><p>Güzel görünüyor değil mi? Bu sayede kodumuzun neresinde hata olduğunu rahatça anlayıp değiştirebiliyoruz. Tek catch bloğu kullandığımız için, kodumuz ilk hatada duracak, ve kodun kalan kısmı da hatalı bir şekilde çalışmaya devam etmeyecek.</p>
<p>Şimdilik bu kadar. Bu yazıda entry yani girdi sınıfımızı tanımladık ve try/catch bloklarımızın kullanımını düzelttik. Bir sonraki yazıda uygulamamızı tamamlamaya devam edeceğiz.</p>
<p>Bir sonraki yazıya şuradan ulaşabilirsiniz:</p>
[embed]https://medium.com/turkce/hi%C3%A7-bilmeyenler-i%CC%87%C3%A7in-nesne-y%C3%B6nelimli-programlamaya-giri%C5%9F-5-s%C4%B1n%C4%B1f%C4%B1-in%C5%9Fa-etmek-83036f340215[/embed]
<hr>

<figure class="wp-caption">

<img src="https://meraklibilisimcihome.files.wordpress.com/2016/12/cceb0-14uozfs7kywroi5ep-uyz5g.jpeg">

<figcaption class="wp-caption-text"><em>Projelerle PHP 7</em></figcaption></figure><p><em>Ben </em><a href="http://mynameismidori.com" target="_blank"><strong><em>Mutlu Koçak</em></strong></a><em>, Bilgisayar Mühendisiyim, ZCPE Sertifikasına sahibim ve “</em><a href="https://www.seckin.com.tr/kitap/911934237" target="_blank"><em>Hiç Bilmeyenler İçin İnternet Programlamaya Giriş — PHP 7</em></a><em>” adlı kitabın yazarıyım. Kitabım: </em><a href="https://www.seckin.com.tr/kitap/911934237" target="_blank"><em>https://www.seckin.com.tr/kitap/911934237</em></a><em><br>Özgeçmişim: </em><a href="http://represent.io/mtkocak.pdf" target="_blank"><em>http://represent.io/mtkocak.pdf</em></a><em> <br>Websitem: </em><a href="http://mynameismidori.com" target="_blank"><em>http://mynameismidori.com</em></a></p>